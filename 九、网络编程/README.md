## 九、网络编程

### 1 - socket 编程步骤

<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/20210826152834.png" alt="socket" style="zoom:67%;" />

#### 服务器的工作流程：

- **（1）创建 socket：**创建服务端的socket。
- **（2）绑定 bind：**把服务端用于通信的地址和端口绑定到socket上。
- **（3）监听 listen：**把socket设置为监听模式。
- **（4）接受连接 accept：**接受客户端的连接。
- **（5）通信 recv( ) / send( ) ：**与客户端通信，接收客户端发过来的报文后，回复处理结果，重复此过程。
- **（6）关闭 close( )：**关闭socket，释放资源。

#### 客户端工作流程：

- **（1）创建 socket：**创建客户端的socket。
- **（2）发送连接 connect( )：**向服务器发起连接请求
- **（3）通信 recv( ) / send( )：**与服务端通信，发送一个报文后等待回复，然后再发下一个报文。重复此过程，直到全部的数据被发送完。
- **（4）关闭 close( )：**关闭socket，释放资源。



### 2 - tcp三次握手的过程中，accept发生在三次握手的哪个阶段？

客户端的connect引起三次握手

服务器在socket、bind、listen后，阻塞在accept，三次握手完成后，accept返回一个fd，因此accept发生在三次握手后。



### 3 - 请问server 端监听端口，但还没有客户端连接进来，此时进程处于什么状态？

这个取决于看服务端的编程模型：

- **正常处于阻塞状态，**
- **如果使用了epoll,select 等这样的 io 复用情况下，处于运行状态**



### 4 - IO模型有哪几种？

- 多路复用IO
- 阻塞IO
- 非阻塞IO
- 信号驱动IO
- 异步IO



### 5 - 什么是IO多路复用？

- I/O多路复用的本质是使用select ，poll 或 epoll函数，挂起进程，当一个或多个IO事件发生之后，将控制返回给用户进程。

- 以服务器编程为例，传统的多进程（多线程）并发模型，在处理用户连接时都是开启一个新的线程或进程去处理一个新的连接，而IO多路复用则是可以在一个进程（线程）中同时监听多个网络IO事件，也就是多个文件描述符



### 6 - IO多路复用的优缺点？

#### 优点：

- 相比基于进程的模型，IO多路复用给程序员更多的程序行为控制
- IO多路复用只需要一个进程就可以处理多个事件，单个进程使得数据共享变得更容易，调试也更容易
- 在单一的进程上下文中，不会有多进程多线程模型的切换开销

#### 缺点：

- 业务逻辑处理困难，编程困难
- 不能充分利用多核处理器



### 7 - 说一说select的缺点？

- 每次调用select，都需要把监听的**文件描述符集合 fd_set**从用户态拷贝多内核态，从算法角度来说就是$O(N)$的时间开销

- 每次调用select返回之后都需要遍历所有文件描述符，判断哪些文件描述符有读写事件发生，也是$O(N)$的时间开销

- 内核对被监控的文件描述符的集合大小做了限制，并且这个是通过宏控制的，大小不可改变，为1024。这一点和上一个缺点是矛盾的，文件描述符设大了，遍历时间就长，其效率也会下降



### 8 - 说一说 poll模型的缺点？

- poll和select本质上没有差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是**poll没有最大文件描述符数量的限制。**
  - select采用fdset（fdset采用了bitmap），**poll采用了数组**，所以表示的描述符比select大
- poll和select同样存在一个缺点就是，文件描述符的数组被整体复制于用户态和内核态的地址空间之间，而不管这些文件描述符是否有事件，它们的开销随着文件描述符数量的增加而线性增大。
- poll返回后，也需要遍历整个描述符的数组才能得到有事件的描述符



### 9 - 说一说epoll的好处 以及 LT和ET？

- epoll解决了**select和poll在文件描述符集合拷贝和遍历上的问题**，能够在一个进程中监听多个文件描述符，并且十分高效
- 在内核当中epoll是以红黑树的方式组织监听事件的，所以**查询开销是 $O(\log{n})$**。采用**回调的方式检测就绪事件，时间复杂度是$O(1)$**
- 在注册监听事件时从用户态将数据传入内核态；当返回时需要将就绪队列的内容拷贝到用户空间



**LT（Level Trigger） 水平触发：** 效率会低于ET触发，尤其在高并发大流量的情况下。但是LT对代码编写要求比较低，不容易出现问题。LT模式服务编写上的表现是：只要有数据没有被获取，内核就不断通知你，因此不用担心时间丢失的情况。

- 水平触发中只要输入缓冲中还剩有数据，就将以事件方式再次注册。接下来通过如下对话介绍边缘触发的事件特性。

**ET（Edge Trigger） 边缘触发：** 效率非常高，在高并发大流量的情况下，会比LT少很多epoll的系统调用，因此效率高。但是对编程要求高，需要细致的处理每个请求，否则容易发生丢失事件的情况

- 边缘触发中输入缓冲收到数据时仅注册1 次该事件。即使输入缓冲中还留有数据，也不会再进行注册。



### 10 - TCP通信中，select到读事件，但是读到的数据量是0，为什么？如何解决？

- select 返回 0 代表超时，返回 1代表出错
- select到读时间，但是读到的数据量为0，说明对方已经关闭了socket的读端。本端关闭读即可
- 当select出错时，会将接口设置为可读又可写。这时候就可以通过判断select的返回值是否为-1确定有没有出错



### 11 - connect方法会阻塞，请问有什么方法可以避免其长时间阻塞？

- 最常用最有效的方法是加定时器
- 也可以采用非阻塞模式
- 或者考虑采用异步传输机制，同步传输与异步传输的主要区别在于同步传输中，如果调用recvfrom后会一致阻塞运行，从而导致调用线程暂时运行；异步传输则立即返回



### 12 - 网络中，如果客户端突然掉线或重启，服务端怎么样才能立刻知道？

若客户端掉线或重启，服务端会收到复位信号



### 13 - socket编程，如果client断电了，服务器如何快速知道？

有数据流动的情况下，可以使用定时器。如果没有数据流动，使用socket选项SO_KEEPALIVE，做心跳检测



### 14- 子网 210.27.48.21/30有多少个可用地址？分别是？

30表示网络号是30位，剩下2位中11是广播地址，00是组播地址，只有01和10可以作为主机地址。

如果广播或组播地址也可用，就是4个



### 15 - TTL是什么？有什么用处？通常哪些工具会用到？

TTL （Time To Live），没经过一个路由TTL会减1，如果变成0，包就会被丢弃。其作用是防止包在有回路的网络上死转，浪费网络资源。ping和traceroute都用了TTL



### 16 - 路由表的作用？linux中如何配置一条默认路由？

路由表是用来决定如何将包从一个子网传送到另一个子网的

在Linux中用 `route add default gw <默认路由器IP>`  配置一条默认路由



### 17 - 如何测试两台主机是否连通？

使用ping命令从一台机器ping另一台机器，如果ping不通，用traceroute可以确定是哪个路由器不能连通，然后再找其他问题



### 18 - fork一子进程后，父进程的全局变量能不能使用？

fork后子进程将拥有父进程的几乎一切资源，父子进程都各自有各自的全局变量，不能通用。不同于线程，对于线程，各个线程共享全局变量



### 19 - 网络编程常用工具

ping 可以用来帮助我们进行网络连通性的探测。

ifconfig，用来显示当前系统中的所有网络设备。

netstat 和 lsof 可以查看活动的连接状况。

tcpdump 可以对各种奇怪的环境进行抓包，进而帮我们了解报文，排查问题。



