## 八、计算机网络

### 0 - OSI七层模型和TCP/IP四层模型是什么？都有什么协议？

**OSI 七层模型及其包含的协议如下:**

- **物理层: **通过媒介传输比特,确定机械及电气规范，**传输单位为bit**，主要包括的协议为：**IEE802.3 CLOCK RJ45**
- **数据链路层:** 将比特组装成帧和点到点的传递,**传输单位为帧**,主要包括的协议为**MAC VLAN PPP**
- **网络层：**负责数据包从源到宿的传递和网际互连，**传输单位为包**,主要包括的协议为**IP ARP ICMP**
- **传输层：**提供端到端的可靠报文传递和错误恢复，**传输单位为报文**,主要包括的协议为**TCP UDP**
- **会话层：**建立、管理和终止会话，**传输单位为SPDU**，主要包括的协议为**RPC NFS**
- **表示层: **对数据进行翻译、加密和压缩,**传输单位为PPDU**，主要包括的协议为**JPEG ASII**
- **应用层: **允许访问OSI 环境的手段,**传输单位为APDU**，主要包括的协议为 **FTP HTTP DNS**

**TCP/IP 4 层模型包括：**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     

- 网络接口层：MAC VLAN
- 网络层: IP ARP ICMP
- 传输层: TCP UDP
- 应用层: HTTP DNS SMTP

<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210912162650789.png" alt="image-20210912162650789" style="zoom: 50%;" />

### 1 - TCP是怎样建立连接的？三次握手

![image-20210921105451290](https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210921105451290.png)

#### 1.0 三次握手

最初两端的TCP进程都处于**CLOSE（关闭）状态**，开始建立连接，服务器Server的TCP服务器进程先创建**传输控制块TCB（Transmission Control Block）**，准备接受客户端进程的连接请求。此时服务器进程处于**LISTEN（收听）**状态。客户端Client的TCP客户端进程也是首先创建TCB，在决定建立TCP连接时，向服务器Server发送连接请求（从而开始三次握手）：

1. 客户端向服务器发送连接请求报文段，将首部中的同步位**SYN置为1**，同时选择一个初始序号ISN(j)。此时客户端进入**SYN-SENT（同步已发送） 状态**。
   - SYN报文段（即SYN=1的报文段）不能携带数据，但要消耗一个序号
2. 服务器收到客户端的SYN报文后，会发送自己的SYN报文，在报文段中把**SYN和ACK都置为1**，同时也为自己选择一个初始序号ISN(k)，**把客户端的ISN+1（j+1）作为ACK的值**，表示自己已经收到了客户端的ISN。这时TCP服务器进行进入**SYN-RCVD（同步收到）状态**。
   - 同理，此报文段也不能携带数据。
3. 客户端收到服务器的SYN报文后，还要向服务器发送 一个ACK报文，确认报文段中的**ACK=1**，也是一样把服务器的ISN+1（k+1）作为ACK的值，表示已经收到了服务端的SYN报文，这时TCP连接已经建立，客户端进入**ESTABLISHED（已建立连接）状态**。当服务器收到客户端的确认后，也进入**ESTABLISHED（已建立连接）状态**。
   - TCP标准规定，ACK报文段可以携带数据，但如果不携带数据则不消耗序号

其中服务器给客户端发送的报文也可以拆成两个报文段，可以先发一个确认报文段（**ACK=1，ack=j+1**），再发送一个同步报文段（**SYN=1，seq=k**）。这样就变成了四次报文握手，但效果一样

#### 1.1 ISN是固定的吗

三次握手的一个重要功能是客户端和服务端交换ISN（Intial Sequence Number），以便让对方知道接下来接受数据的时候如何按序列号组装数据

如果ISN是固定的，攻击者很容易猜出后续的确认号，因此**ISN是动态生成的**

#### 1.2 什么是半连接队列？

服务器第一次接收到客户端的SYN之后，就会处于SYN_RCVD状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，即半连接队列。

对应的是全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列里。如果队列满了就有可能出现丢包的现象

#### 1.3 三次握手过程中可以携带数据吗？

TCP规定，SYN报文段（即SYN=1的报文段）不能携带数据，但要消耗一个序号。所以**第一次、第二次握手不可以携带数据，但第三次可以携带数据**

**如果SYN报文段可以携带数据，攻击者可以在第一次握手中的SYN报文中放入大量数据，因为攻击者根本不理会服务器的接收、发送能力是否正常，疯狂发送SYN报文，这会让服务器花费大量时间和内存空间来接收这些空报文。服务器更容易受到攻击。**

对于第三次握手，此时客户端已经处于established状态，对于客户端来说，已经建立起了连接，并且也知道服务器的接收、发送能力是正常的，所以可以携带数据。



### 2 - TCP是怎样断开连接的？四次挥手

#### 四次挥手

<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210921105809482.png" alt="image-20210921105809482" style="zoom:67%;" />

数据传输结束后，通信的双方都可释放连接，现在客户端和服务端都处于**ESTABLISHED（已建立连接）状态**。

1. 第一次挥手：客户端向服务器发送一个FIN报文，首部的FIN=1，同时报文给自己指定一个序号（m），此时客户端进入**FIN_WAIT_1 （终止等待1）状态**，但客户端依然可以接收服务器发送来的数据。
   - TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。



2. 第二次挥手：服务端收到了客户端的FIN报文，会发送ACK报文进行确认，把收到报文的序列号的值+1（m+1）作为ACK报文的序列号的值，表明已经收到了客户端的报文，服务器进入**CLOSE-WAIT（关闭等待）状态**
   - TCP服务器进程这时应通知高层应用程序，客户端到服务端这个方向的连接就释放了，此时TCP连接处于**半关闭（HALF-CLOSE）状态**，即客户端已经没有数据要发送了，但服务器若发送数据，客户端仍要接收。客户端收到服务端的确认后，进入**FIN-WAIT-2（终止等待2）状态**。等待服务端发出的连接释放报文段。



3. 第三次挥手：当服务器没有数据要发送了，也想要断开连接，会给客户端发送FIN报文，且指定一个序列号（n），服务器进入了**LAST-ACK（最后确认）状态**。



4. 第四次挥手：客户端收到FIN之后，一样会发送一个ACK报文作为应答，且把服务端的序号+1（n+1）作为自己ACK报文的序号。然后进入**TIME-WAIT（时间等待）**状态，等待**2MSL**（**MSL：报文段最大生存时间**），然后关闭连接。



#### 为什么TIME-WAIT状态 必须等待2MSL的时间呢？

1. **为了保证A发送的最后一个ACK报文段能够到达B。**这个ACK报文段有可能丢失，因而使处在LAST_ACK状态的B收不到对已发送FIN+ACK报文段的确认。B会超时重传这个FIN+ACK报文段，而A就能在2MSL时候内（超时+1MSL传输）收到这个重传的FIN+ACK报文段。接着A重传一次确认，重新启动2MSL计时器，最后A和B都正常进入CLOSED状态。如果A在TIME-WAIT状态不等待一段时间，而是在发送完ACK报文段后立即释放连接，那么就无法收到B重传的FIN+ACK报文段，因而也不会再发送一次确认报文段，这样B就无法按照正常流程进入CLOSED状态。
2. **防止已失效的连接请求报文段出现在本连接中。**A在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段在网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。

**2MSL 意义:**

- 保证最后一次握手报文能到服务器，能进行超时重传。
- 2MSL 后，这次连接的所有报文都会消失，不会影响下一次连接。



#### TIME_WAIT的作用

大多数 BSD 派生的系统一样，Linux 系统里有一个硬编码的字段，名称为TCP_TIMEWAIT_LEN，其值为 60 秒。也就是说，Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒。

```cpp
#define TCP_TIMEWAIT_LEN (60*HZ) 
/* how long to wait to destroy TIME-WAIT state, about 60 seconds  */
```

**只有发起连接终止的一方会进入 TIME_WAIT 状态。**

TIME_WAIT可以：

- **确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。**
  - TCP 假设报文会出错，需要重传。如果客户端的ACK 报文没有传输成功，那么服务器就会重新发送 FIN 报文。如果客户端 没有维护 TIME_WAIT 状态，而直接进入 CLOSED 状态，它就失去了当前状态的上下文，只能回复一个 RST 操作，从而导致被动关闭方出现错误。现在客户端知道自己处于 TIME_WAIT 的状态，就可以在接收到 FIN 报文之后，重新发出一个 ACK 报文，使得服务器可以进入正常的 CLOSED 状态。
- **为了让旧连接的重复分节在网络中自然消失。**
  - 2MSL 的时间是从客户端接收到 FIN 后发送 ACK 开始计时的；如果在 TIME_WAIT 时间内，因为客户端的 ACK 没有传输到服务器，客户端又接收到了服务器重发的 FIN 报文，那么 2MSL 时间将重新计时。道理很简单，因为 2MSL 的时间，目的是为了让旧连接的所有报文都能自然消亡，现在客户端重新发送了 ACK 报文，自然需要重新计时，以便防止这个 ACK 报文对新可能的连接化身造成干扰。
  - 如果迷走报文到达时，发现 TCP 连接四元组（源 IP，源端口，目的 IP，目的端口）所代表的连接不复存在，那么这个报文会被丢弃。
  - 经过 2MSL 这个时间，足以让两个方向上的分组都被丢弃，使得原来连接的分组在网络中都自然消失，再出现的分组一定都是新化身所产生的。



#### TIME_WAIT的危害？

- 第一是内存资源占用，但不是很严重，基本可以忽略。
- 第二是对端口资源的占用，一个 TCP 连接至少消耗一个本地端口。端口资源也是有限的，一般可以开启的端口为 32768～61000 ，也可以通过net.ipv4.ip_local_port_range指定，如果 TIME_WAIT 状态过多，会导致无法创建新连接。



#### 如何优化TIME_WAIT？

**net.ipv4.tcp_max_tw_buckets：**

一个暴力的方法是通过 sysctl 命令，将系统值调小。这个值默认为 18000，当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将所有的 TIME_WAIT 连接状态重置，并且只打印出警告信息。这个方法过于暴力，而且治标不治本，带来的问题远比解决的问题多，不推荐使用。

**调低 TCP_TIMEWAIT_LEN：**

重新编译系统这个方法是一个不错的方法，缺点是需要“一点”内核方面的知识，能够重新编译内核。

**net.ipv4.tcp_tw_reuse：更安全的设置：**

Linux 系统对于net.ipv4.tcp_tw_reuse的解释如下:

```
Allow to reuse TIME-WAIT sockets for new connections when it is safe from protocol viewpoint. Default value is 0.It should not be changed without advice/request of technical experts.
```

即从协议角度理解如果是安全可控的，可以复用处于 TIME_WAIT 的套接字为新的连接所用。

那么什么是协议角度理解的安全可控呢？主要有两点：

- 只适用于连接发起方（C/S 模型中的客户端）；
- 对应的 TIME_WAIT 状态的连接创建时间超过 1 秒才可以被复用。
  - 使用这个选项，还有一个前提，需要打开对 TCP 时间戳的支持，即net.ipv4.tcp_timestamps=1（默认即为 1）。

TCP 协议也在与时俱进，RFC 1323 中实现了 TCP 拓展规范，以便保证 TCP 的高可用，并引入了新的 TCP 选项，两个 4 字节的时间戳字段，用于记录 TCP 发送方的当前时间戳和从对端接收到的最新时间戳。由于引入了时间戳，前面提到的 2MSL 问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。



#### 总结：

**TIME_WAIT的作用：**

1） 确保对方能够正确收到最后的ACK，帮助其关闭；

2） 防迷走报文对程序带来的影响。

**TIME_WAIT的危害：**

1） 占用内存；

2） 占用端口。



### 3 - TCP三次握手和四次挥手的原因

#### 三次握手的原因：

三次握手可以**防止已经失效的连接请求报文突然又传输到服务器端导致的服务器资源浪费。**

例如，客户端先发送了一个SYN，但是由于网络阻塞，该SYN 数据包在某个节点长期滞留。然后客户端又重传SYN 数据包并正确建立TCP 连接，然后传输完数据后关闭该连接。该连接释放后失效的SYN 数据包才到达服务器端。在二次握手的前提下，服务器端会认为这是客户端发起的又一次请求，然后发送SYN ，并且在服务器端创建socket 套接字，一直等待客户端发送数据。但是由于客户端并没有发起新的请求，所以会丢弃服务端的SYN 。此时服务器会一直等待客户端发送数据从而造成资源浪费。

#### 四次挥手的原因：

因为当处于LISTEN状态的服务器端收到来自客户端的SYN报文(客户端希望新建一个TCP连接)时，它可以把ACK(确认应答)和SYN(同步序号)放在同一个报文里来发送给客户端。**但在关闭TCP连接时，当收到对方的FIN报文时，对方仅仅表示对方已经没有数据发送给你了，但是自身可能还有数据需要发送给对方**，则等你发送完剩余的数据给对方之后，再发送FIN报文给对方来表示你数据已经发送完毕，并请求关闭连接，所以通常情况下，这里的ACK报文和FIN报文都是分开发送的。



### 4 - 请问tcp 握手为什么两次不可以？为什么不用四次？

#### 两次不可以：

- TCP 是全双工通信，两次握手只能确定单向数据链路是可以通信的，并不能保证反向的通信正常



**详细解释：**

这个问题的本质是：在信道不可靠的情况下, 通信双发需要就某个问题达成一致. 需要几次通信？

对于此问题，无论在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足**"在不可靠信道上可靠地传输信息"**这一需求所导致的

具体来说：

- TCP连接的双方要确保各自的收发消息的能力都是正常的。
- 客户端第一次发送握手消息到服务端，服务端接收到握手消息后把ack和自己的syn一同发送给客户端，这是第二次握手，当客户端接收到服务端发送来的第二次握手消息后，客户端可以确认“服务端的收发能力OK，客户端的收发能力OK”，但是服务端只能确认“客户端的发送OK，服务端的接收OK”，
- 所以还需要第三次握手，客户端收到服务端的第二次握手消息后，发起第三次握手消息，服务端收到客户端发送的第三次握手消息后，就能够确定“服务端的发送OK，客户端的接收OK”，
- 至此，客户端和服务端都能够确认自己和对方的收发能力OK，TCP连接建立完成。

#### 不用四次：

- 本来握手应该和挥手一样都是需要确认两个方向都能联通的，本来模型应该是：
  - 1. 客户端发送syn0 给服务器
  - 2. 服务器收到syn0，回复ack(syn0+1)
  - 3. 服务器发送syn1
  - 4. 客户端收到syn1，回复ack(syn1+1)
- **因为TCP是全双工的，上边的四步确认了数据在两个方向上都是可以正确到达的，但是2，3 步没有没有上下的联系，可以将其合并，加快握手效率，所有就变成了3 步握手。**



### 5 - TCP协议是如何保证可靠传输的？

- （1）**数据包校验：**目的是检测数据在传输过程中的是否发生变化，若校验包有错，则丢弃报文段并且不给出响应，这时TCP发送端超时后重发数据
- （2）**对失序数据包重排序：**既然TCP报文段作为IP数据包来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能失序。TCP将对失序数据重新排序，然后才交给应用层
- （3）**丢弃重复数据**
- （4）**应答机制：**当TCP一端收到另一端的数据，它将发送一个确认。这个确认不是立即发送，通常会将推迟几分之一秒；
- （5）**超时重发：**当TCP发出一个段，会启动一个定时器，等待目的端确认收到这个报文段，如果不能及时收到一个确认，将重发这个报文段
- （6）**流量控制：**TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。TCP使用的流量控制协议是可变大小的滑动窗口协议。
- （7）**拥塞控制算法（慢开始、拥塞避免、快重传、快恢复）**



### 6 - TCP可靠性原理？

可靠传输有如下两个特点：

- 传输信道无差错，保证传输数据正确
- 不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据
  - 首先，采用三次握手建立TCP连接，四次握手释放TCP连接，保证了传输信道是可靠的
  - 其次，TCP采用了连续ARQ协议（回退N（Go-back-N），超时自动重传）来保证数据传输的正确性，使用滑动窗口协议来保证接收方能够及时处理所接收到的数据，进行流量控制
  - 最后，TCP使用慢开始、拥塞避免、快重传、快恢复来进行拥塞控制，避免网络拥塞



### 7 - 谈谈你对流量控制的理解？

TCP利用窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以同来控制发送方窗口的大小，从而影响发送方的发送速率。将窗口字段设置为0，则发送方不能发送数据。



### 8 - 谈谈你对TCP滑动窗口的了解？

- TCP利用滑动窗口实现流量控制。滑动窗口（Sliding Window）是一种流量控制技术。在早期的网络通信中，通信双方不会考虑网络的拥挤情况而直接发送数据。由于双方不知道网络拥塞状况，同时发送数据，导致中间节点阻塞丢包，谁也发不了数据，所有就有了滑动窗口机制来解决此问题

- TCP中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可用于接收数据；发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。

- 当滑动窗口为0时，发送方一般不能再发送数据报，有两种情况除外：

  - 一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。

  - 一种情况是发送方可以发送一个1字节的数据报来通知接收方重新声明它希望接收的下一个字节及发送方的滑动窗口大小。

    

### 9 - 谈下对TCP拥塞控制的理解？

- 拥塞控制和流量控制不同：
  - 拥塞控制是一个全局性的过程
  - 流量控制是点对点通信量的控制

- 在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变差，这种情况就叫拥塞。

- 拥塞控制就是为了防止过多的数据注入到网络中，这样就使网络中的路由器或链路不致于过载。拥塞避免所要做的都有一个前提，就是网络能够承受现有的网络负载，拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点的通信量的控制，是个端到端的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便于接收端来得及接收。

为了进行拥塞控制，TCP发送方要维持一个拥塞窗口（cwnd）。拥塞窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取拥塞窗口和接收方接收窗口中较小的一个。 **swnd = min(cwnd, rwnd)**

**TCP的拥塞控制采用了四种算法 （慢开始、拥塞避免、快重传、快恢复）**，在网络层也可以使路由器采用适当的分组丢弃策略（如：主动队列管理 AQM），以减少网络拥塞的发生。

- **慢启动：**定义拥塞窗口，一开始将该窗口大小设为`1`，之后每次收到确认应答（经过一个`RTT`），将拥塞窗口大小乘2。如果一次性把大量数据注入网络，那么可能会引起网络阻塞，较好的方法是先探测一下，即由小到大逐渐扩大发送窗口。
- **拥塞避免：**设置慢启动阈值，一般开始都设为`65536`。拥塞避免是指**当拥塞窗口大小达到这个阈值，拥塞窗口的值不再指数上升，而是加法增加**（每次确认应答/每个RTT，拥塞窗口大小`+1`），以此来避免拥塞。
- 将报文段的超时重传看做拥塞，则一旦发生超时重传，需要先**将阈值设为当前窗口大小的一半**，并且将窗口大小设为初值1，然后重新进入慢启动过程。为了避免这种情况，从而有了快重传算法。
- **快重传：**当接收方收到`M1`和`M2`后，都分别及时发送确认，但是如果接收方没有收到`M3`，却收到了`M4`、`M5`和`M6`，但接收方收到后也仍然要再次分别发出对`M2`的重复确认，这样发送方就收到了4个对`M2`的确认，其中后三个是重复的确认。**快重传算法规定，发送方只要一连收到3个重复确认，就知道接收方没有收到`M3`因而应当立即进行快重传，这样就不会出现超时。**
- **快恢复：**当发送方知道只是丢失了个别的报文段，不会启动慢开始算法，而是执行快恢复算法。将阈值设为当前窗口大小的一半，同时设置拥塞窗口为阈值的大小，然后执行拥塞避免算法。

通过拥塞控制算法，在TCP 通信时，网络吞吐量呈现逐渐的上升，并且随着拥堵来降低吞吐量，再进入慢慢上升的过程，网络不会轻易的发生瘫痪。



### 10 - TCP拥塞控制如何实现的？

TCP发送方要维持一个拥塞窗口（cwnd），而发送窗口的值是 **swnd = min(cwnd, rwnd)，**也就是拥塞窗口和接收窗口中的最小值。

拥塞控制是防止过多的数据注入网络，使得网络中的路由器或者链路过载。流量控制是点对点的通信量控制，而拥塞控制是全局的网络流量整体性的控制。**发送双方都有一个拥塞窗口— cwnd。**

**（1）慢开始：**

- 最开始发送方的拥塞窗口 cwnd 为1，由小到大逐渐增大发送窗口和拥塞窗口。每经过一个传输轮次，拥塞窗口cwnd 加倍。当cwnd 超过慢开始门限，则使用拥塞避免算法，避免cwnd 增长过大。

**（2）拥塞避免：**

- 每经过一个往返时间RTT，拥塞窗口cwnd 就增长1。
- 在慢开始和拥塞避免的过程中，一旦发现网络拥塞，就把慢开始门限设为当前值的一半，并且重新设置拥塞窗口 cwnd 为1，重新慢启动。（乘法减小，加法增大）

**（3）快重传：**

- 接收方每次收到一个失序的报文段后就立即发出重复确认，发送方只要连续收到三个重复确认就立即重传（尽早重传未被确认的报文段）。

**（4）快恢复：**

- 当发送方连续收到了三个重复确认，就乘法减半（慢开始门限减半），将当前的拥塞窗口 cwnd 设置为慢开始门限，并且采用拥塞避免算法（连续收到了三个重复请求，说明当前网络可能没有拥塞）。
- 采用快恢复算法时，慢开始只在建立连接和网络超时才使用。



### 11 - 什么是粘包？TCP粘包是怎么产生的？

#### 什么是粘包？

如果客户端连续不断的向服务端发送数据包时，服务端接受的数据会出现两个数据报粘在一起的情况。

**接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出一块，这种情况即发生了拆包和粘包，**拆包和粘包的问题导致接收端在处理的时候会非常困难，因为无法区分一个完整的数据包。

- TCP是基于字节流的，虽然应用层和TCP传输层之间的数据交互是大小不等的数据块，但是TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界。
- 从TCP的帧结构上也可以看出，在TCP的首部没有表示数据长度的字段

基于以上两点，在使用TCP传输数据时，才有粘包或拆包现象发生的可能。一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包



### 12 - TCP粘包是怎么产生的？

- 发送方产生粘包
  - 采用TCP协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据。但当发送的数据包过于小的时候，TCP协议默认会启用Nagle算法，将这些较小的数据包进行合并发送；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来的时候它就已经是粘包的状态了。

- 接收方产生粘包
  - 接收方采用TCP协议接收数据时的过程是这样的：数据到接收方，从网络模型的下方传递至传输层，传输层的TCP协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C采用recv、read等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 > 应用层拿数据速度）

### 13 - 怎么解决拆包和粘包？

分包机制一般有两个通用的解决方法：

- 特殊字符控制
- 在包头首部添加数据包的长度

如果使用netty框架的话，就有专门的编码器和解码器解决拆包和粘包的问题了

#### UDP没有粘包问题！

UDP没有粘包问题，但是有丢包和乱序问题。不完整的包是不会有的，收到的都是完全正确的包。传送的数据单位协议是UDP报文或用户数据报，发送的时候既不合并，也不拆分。



### 14 - 说一说TCP与UDP的特点？

#### TCP协议的主要特点：

1. **TCP是面向连接的运输层协议；**面向连接就是双方在传输数据之前，必须建立一条通道，例如三次握手就是建立通道的一个过程，四次挥手则是结束销毁通道的一个过程
2. **每一条TCP连接只能有两个端点，是点对点的**
3. **TCP提供可靠的传输服务，传送的数据无差错、不丢失、不重复、按序到达**
4. TCP提供全双工的通信。允许通信双方的应用进程在任何时候都可以发送数据，因为两端都设有发送缓存和接收缓存
5. **面向字节流。**虽然应用程序与TCP交互是一次一个大小不等的数据库，但TCP把这些数据看成一连串无结构的字节流，它不保证接收方收到的数据块和发送方发送的数据块具有对应大小关系，例如发送方应用程序交给发送方的TCP10个数据块，但接收方的TCP可能只用了4个数据块就保证收到的字节流交付给上层的应用，但字节流完全一样。

#### UDP协议的主要特点：

1. UDP是无连接的传输层协议
2. UDP支持一对一、一对多、多对多的交互通信
3. UDP是尽最大努力交付，但不保证可靠交付，不能保证数据的有序性
4. UDP是面向报文的，对应用层交下来的报文，不合并，不拆分，**只保留原报文的边界**
5. UDP没有拥塞控制，即时网络出现拥塞也不会降低发送速率
6. UDP的首部开销小，只有8个字节



### 15 - 说一说TCP与UDP的区别？：

（1）连接：

- TCP 是面向连接的传输层协议，即传输数据之前必须先建立好连接。
- UDP是无连接的。

（2）服务对象：

- TCP 是点对点的两点间服务，即一条 TCP 连接只能有两个端点;
- UDP 支持一对一，一对多，多对一，多对多的交互通信。

（3）可靠性：

- TCP 是可靠交付:无差错，不丢失，不重复，按序到达。 
- UDP 是尽最大努力交付，不保证可靠交付。 

（4）拥塞控制，流量控制：

- TCP 有拥塞控制和流量控制保证数据传输的安全性。

- UDP 没有拥塞控制，网络拥塞不会影响源主机的发送效率。 

（5) 报文长度：

- TCP 是动态报文长度，即 TCP 报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的。 
- UDP 面向报文，不合并，不拆分，保留上面传下来报文的边界。

（6）首部开销：

- TCP 首部开销大，首部 20 个字节。
- UDP 首部开销小，8 字节。(源端口，目的端口，数据长度，校验和)

（7）TCP传输速度比UDP慢，TCP是重量级协议、UDP是轻量级协议



### 16 - TCP和UDP适用场景有哪些？

TCP 是可靠的但传输速度慢，UDP 是不可靠的但传输速度快。因此 在选用具体协议通信时，应该根据通信数据的要求而决定。

文件传输、重要状态的 更新等适合使用TCP 

视频传输、实时通信等使用UDP效果更好



### 17 - 基于TCP和UDP的常用协议有哪些？

- TCP对应的应用层协议：

  - **HTTP ：80端口 、HTTPS：443端口**
  - **FTP：21端口，**文件传输协议
  - **TELNET：23端口，**远程终端协议，是一种用于远程登录的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。
  - **SMTP：25端口，**简单邮件传输协议，用于发送邮件
  - **POP3：110端口，**用于接收邮件

- UDP对应的应用层协议：

  - **TFTP：69端口，**简单文件传输协议
  - **DNS：53端口，**用于域名解析服务，将域名地址转换为IP地址
  - **SNMP：161端口**：简单网络管理协议，用来管理网络设备
  - DHCP：动态主机配置协议，DHCP服务器使用UDP端口67，DHCP客户端从UDP端口68发送DHCP发现报文

  UDP的其他协议：RIP（路由信息协议），位于网络层



### 18 - 网络层如何知道报文应该给哪个应用程序，又如何区分UDP报文和TCP报文？

**根据端口分区**

**看报文头部的协议标识字段，17是UDP，6是TCP**



### 19 - 说一说 HTTP1.0、HTTP1.1、HTTP2.0的区别？

#### HTTP1.0

- **HTTP1.0规定浏览器与服务器只保持短暂的连接，**浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接。就像打电话一样，一次只能说一件事，说完就要挂断，又因为TCP连接建立一次需要三次握手，所以效率很低。

**如果不想断开连接，需要在HTTP相应的Connection字段指定为keep-live**

```cpp
connection:keep-alive;
```

#### HTTP1.1

- **HTTP1.1引进了持久连接，TCP连接默认不关闭，可以被多个请求复用。**客户端和服务端发现对方一段时间没有活动后，可以主动关闭连接；或者客户端在最后一个请求时，主动告诉服务端要关闭连接。

- HTTP1.0就像打一次电话只能说一次事，HTTP1.1是打完电话先不直接挂断，而是持续一会，这期间如果有事情还可以再次沟通。

- HTTP1.1还引入了管道机制，即在同一个TCP连接里，客户端可以同时发送多个请求，这样就进一步改进了HTTP协议的效率。

#### HTTP2.0

- **HTTP2.0采用了多路复用，即在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按顺序一一对应**。能这样做有一个前提，就是HTTP2.0进行了二进制分帧，即会将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码。

- 负责这个拆分、组装请求和二进制帧的一层就叫做**二进制分帧层**

- 也就是说，老板可以同时下达多个命令，员工也可以收到请求A和请求B，于是先回应A，结果发现处理A非常耗时，于是就发送A请求已经处理好的部分，接着回应B请求，完成后 ，再发送A请求剩下的部分。A请求的两部分响应再组合到一起发送给老板

- 除此之外还有一些其他的优化，比如**Header压缩**、**服务端推送**等
  - Header压缩就是压缩老板和员工之间的对话
  - 服务端推送就是员工事先把一些老板可能询问的事情提前发送到老板的手机上（缓存）。这样老板想要知道的时候就可以直接读取短信（缓存）了。

#### HTTP发展历程：

1. HTTP 协议始于三十年前蒂姆·伯纳斯 - 李的一篇论文；
2. HTTP/0.9 是个简单的文本协议，只能获取文本资源；
3. HTTP/1.0 确立了大部分现在使用的技术，但它不是正式标准；
4. HTTP/1.1 是目前互联网上使用最广泛的协议，功能也非常完善；
5. HTTP/2 基于 Google 的 SPDY 协议，注重性能改善，但还未普及；
6. HTTP/3 基于 Google 的 QUIC 协议，是将来的发展方向。



### 20 - HTTP协议有哪些特点？

#### HTTP是什么？

1. **HTTP 是一个用在计算机世界里的协议，它确立了一种计算机之间交流通信的规范，以
   及相关的各种控制和错误处理方式。 **（定义）
2. HTTP 专门用来在两点之间传输数据，不能用于广播、寻址或路由。
3. HTTP 传输的是文字、图片、音频、视频等超文本数据。
4. HTTP 是构建互联网的重要基础技术，它没有实体，依赖许多其他的技术来实现，但同
   时许多技术也都依赖于它。

#### HTTP协议概念：

- HTTP 协议是 Hyper Text Transfer Protocol(超文本传输协议)的缩写，是用于从万维网(WWW:World Wide Web)服务器传输超文本到本地浏览器的传送协议。
- HTTP 是一个基于 TCP/IP 通信协议来传递数据(HTML 文件，图片文件，查询结果等)。
- HTTP 是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒 体信息系统。
- HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端（即 WEB 服务器）发送所有请求。Web 服务器根据接收到的请求后，向客户端发送响应信息。

#### HTTP协议特点：

1. 简单快速：

- 客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。 每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。

2. 灵活：

- HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记

3. 无连接：

- 无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应 答后，即断开连接。采用这种方式可以节省传输时间。

4. 无状态：

- HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如 果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方 面，在服务器不需要先前信息时它的应答就较快。

5. 支持 B/S 及 C/S 模式
6. 默认端口为80
7. 基于TCP协议



### 21 - HTTP返回码

HTTP 协议的响应报文由状态行、响应头部和响应包体组成，其响应状态码总体描述如下：

- 1xx：**指示信息**--表示请求已接收，继续处理。
- 2xx：**成功**--表示请求已被成功接收、理解、接受。
- 3xx：**重定向**--要完成请求必须进行更进一步的操作。
- 4xx：**客户端错误**--请求有语法错误或请求无法实现。
- 5xx：**服务器端错误**--服务器未能实现合法的请求。

常见状态代码、状态描述的详细说明如下：

- **200 OK：客户端请求成功。**
- 206 partial content 服务器已经正确处理部分GET 请求，实现断点续传或同时分片下载，该请求必须包含Range 请求头来指示客户端期望得到的范围
- 300 multiple choices（可选重定向）:被请求的资源有一系列可供选择的反馈信息，由浏览器/用户自行选择其中一个。
- **301 moved permanently（永久重定向）：该资源已被永久移动到新位置，将来任何对该资源的访问都要使用本响应返回的若干个URI 之一。**
- **302 move temporarily(临时重定向)：指页面暂时性转移，表示资源或页面暂时转移到另一个位置，常被用作网络劫持，容易导致网站降权，严重时网站会被封掉，不推荐使用**
- 304：not modified :如果客户端发送一个待条件的GET 请求并且该请求以经被允许，而文档内容未被改变，则返回304,该响应不包含包体（即可直接使用缓存）。
- **403 Forbidden：服务器收到请求，但是拒绝提供服务。**
- **404  ：服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置 您所请求的资源无法找到" 的个性页面**



### 22 - HTTP如何实现长连接？在什么时候会超时？

**通常在头部（请求和响应头）设置Connection: keep-alive，HTTP1.0协议支持，但默认是关闭，从HTTP1.1协议开始，连接默认都是长连接**

**长连接什么时候会超时？**

- HTTP一般会有httpd守护进程，里面可以设置 keep-alive timeout，当TCP连接闲置时间超过这个时间就会关闭，可以在HTTP的header里面设置超时时间
- TCP的 keep-alive 包含三个参数，支持在系统内核的 net.ipv4 里面设置：当TCP连接之后，设置了tcp_keepalive_time时间，则会发送侦测包，如果没有收到对方的ACK，那么每隔tcp_keepalive_intvl再发一次，直到发送了tcp_keepalive_probes，就会丢弃该链接
  - tcp_keepalive_time = 1800
  - tcp_keepalive_intvl = 15
  - tcp_keepalive_probes = 5
- **实际上HTTP没有长短连接，只有TCP有，TCP长连接可以复用一个TCP连接来发起多次HTTP请求，这样就可以减少资源消耗，比如一次请求HTML，可能还需要请求后续的 JS/CSS/图片等。**（重要！！！）



### 23 - HTTP方法有哪些？

客户端发送的请求报文第一行为行为请求，包含了方法字段：

1. **GET：获取资源，当前网络绝大部分使用的都是GET**
2. **POST：传输实体主体**
3. **HEAD：获取报文首部，和GET方法类似，但是不返回报文实体主体部分**
4. **PUT：上传文件，由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法**
5. PATCH：对资源进行部分修改。PUT也可以用于修改资源，但是只能完全替代原始资源，PATCH允许部分修改
6. OPTIONS：查询指定的URL支持的方法
7. CONNECT：要求在与代理服务器通信时建立隧道，使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。
8. TRACE：追踪路径，服务器会将通信返回给客户端。发送请求时，在Max-Forwards首部字段中填入数值，每经过一个服务器就减1，当数值为0时就停止传输。通常不会使用TRACE，因为其易受到XST攻击（Cross-Site Tracing，跨站追踪）。



### 24 - forward 和 redirect 的区别？

Forward 和 Redirect 代表了两种请求转发方式：直接转发和间接转发。

- 直接转发方式（Forward）：客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其他信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。
- 间接转发方式（Redirect）：实际是两次HTTP请求，服务端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的



### 25 - GET 和 POST 的区别

#### 概括：

- **对于GET 方式的请求，浏览器会把http header 和data 一并发送出去，服务器响应200（返回数据）**

- **而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）**

#### 区别：

- （1）get 参数通过 url 传递，post 放在 request body 中。
- （2）get 请求在 url 中传递的参数是有长度限制的，而 post 没有。
- （3）get 比 post 更不安全，因为参数直接暴露在 url 中，所以不能用来传递敏感信息。
- （4）get 请求只能进行 url 编码，而 post 支持多种编码方式。
- （5）get 请求会浏览器主动 cache，而 post 支持多种编码方式。
- （6）get 请求参数会被完整保留在浏览历史记录里，而post 中的参数不会被保留。
- （7）GET 和POST 本质上就是TCP 连接，并无差别。但是由于HTTP 的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。
- （8）GET 产生一个TCP 数据包；POST 产生两个TCP 数据包。



### 26 - GET请求中URL编码的意义？

**在GET请求中会对URL中非西方文字进行编码，这样做是为了避免歧义**

对一些特殊字符如&，解析时会产生歧义，比如将 `name1=va&lu=e1`编码成 `name1=va%26lu%3D`，这样服务端就会把%后的字节当成普通的字节，不会把它当成各个参数或键值对的分隔符。



### 27 - HTTP的过程是什么？

HTTP 协议定义 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传 送给客户端。HTTP 协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包 含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的 内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。

**（1）客户端连接到Web服务器：**

一个HTTP 客户端，通常是浏览器，与Web 服务器的HTTP 端口（默认为80）建立一个TCP套接字连接。例如，http://www.baidu.com。

**（2）发送HTTP请求：**

通过TCP 套接字，客户端向Web 服务器发送一个文本的请求报文，一个请求报文由4 部分组成：

- 请求行
- 请求头部
- 空行
- 请求数据

**（3）服务器接受请求并返回HTTP响应：**

Web 服务器解析请求，定位请求资源。服务器将资源复本写到TCP 套接字，由客户端读取。一个响应由4 部分组成：

- 状态行
- 响应头部
- 空行
- 响应数据

**（4）释放连接TCP 连接：**

- 若connection 模式为close，则服务器主动关闭TCP 连接，客户端被动关闭连接，释放TCP连接;
- 若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;

**（5）客户端浏览器解析HTML 内容：**

- 客户端浏览器首先解析**状态行**，查看表明请求是否成功的状态代码。
- 然后解析每一个**响应头**，响应头告知以下为若干字节的HTML 文档和文档的字符集。
- 客户端浏览器**读取响应数据HTML**，根据HTML 的语法对其进行格式化，并在浏览器窗口中显示。



### 28 - 在浏览器输入URL地址到显示主页的过程？

**大概过程：**

（1）浏览器向DNS 服务器请求解析该URL 中的域名所对应的IP 地址；
（2）解析出IP 地址后，根据该IP 地址和默认端口80，和服务器建立TCP 连接；
（3）浏览器发出读取文件（URL 中域名后面部分对应的文件）的HTTP 请求，该请求报文作为TCP 三次握手的第三个报文的数据发送给服务器；
（4）服务器对浏览器请求作出响应，并把对应的html 文本发送给浏览器；
（5）释放TCP 连接；
（6）浏览器将该html 文本解析后显示网页内容；

**细致过程（笔试原题，排序）：**

1、浏览器输入URL，先解析URL地址是否合法

2、浏览器检查是否有缓存（浏览器缓存 - 系统缓存 - 路由器缓存）。如果有，直接显示。没有，进行（3）

3、在发送HTTP请求前，需要域名解析（DNS解析），解析获取对应的IP地址

4、浏览器向服务器发起TCP连接，进行TCP连接的三次握手

5、握手成功后，浏览器向服务器发送HTTP请求，请求数据包

6、服务器收到请求，进行处理后将数据发送给浏览器（请求报文作为TCP 三次握手的第三个报文的数据发送给服务器）

7、浏览器收到HTTP响应

8、浏览器解析响应，如果响应可以缓存则存入缓存

9、浏览器发送请求获取嵌入在HTML的资源（HTML、CSS、JS等），对于未知类型，会弹出对话框

10、浏览器发送异步请求

11、页面全部渲染结束显示网页



### 29 - 搜索 www.baidu.com，会用到计算机网络中的那些层？每层的作用？

#### 全过程：

1、**域名解析：**浏览器获得URL地址，向操作系统请求该URL对应的IP地址，操作系统查询DNS（首先查询本地HOST文件，没有则查询网络）获得对应的IP地址

2、确认IP和端口号（不注明端口号则默认为80端口）后，则可以向该IP地址对应的服务器的该端口号发起TCP连接请求

3、服务器接收到TCP连接请求后，回复可以连接请求

4、浏览器收到回传的数据后，还会向服务器发送数据包，表示三次握手结束

5、三次握手成功后，开始通讯，根据HTTP协议的要求，组织一个请求的数据包，里面包含请求的资源路径、你的身份信息等，例如，www.abc.com/images/1/表示的资源路径是images/1/，发送后，服务器响应请求，将数据返回给浏览器，数据可以是根据HTML协议组织的网页，里面包含页面的布局、文字等等，也可以是图片或者脚本程序等，如果资源路径指定的资源不存在，服务器就会返回404错误，如果返回的是一个页面，则根据页面里的一些外链URL地址，重复上述步骤，再次获取

6、渲染页面，并开始响应用户的操作

7、窗口关闭时，浏览器终止与服务器的连接

#### 用到的层和协议：

1. 浏览器中输入URL

2. **浏览器要将URL 解析为IP 地址，解析域名就要用到DNS 协议**，首先主机会查询DNS 的缓存，如果没有就给本地DNS 发送查询请求。DNS 查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS 服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP 地址。**DNS 服务器是基于UDP的，因此还会用到UDP 协议。**
3. **得到 IP 地址后，浏览器就要与服务器建立一个HTTP 连接，因此要用到 HTTP 协议，**HTTP 协议报文格式上面已经提到。**HTTP 生成一个get 请求报文，将该报文传给传输层处理，所以还会用到TCP 协议。**如果采用HTTPS 还会使用HTTPS 协议先对HTTP数据进行加密。传输层如果有需要先将HTTP 数据包分片，分片依据路径MTU 和MSS。**TCP 的数据包然后会发送给网络层，用到IP协议。**网络层通过路由选路，一跳一跳发送到目的地址。当然**在一个网段内的寻址是通过以太网协议实现(也可以是其他物理层协议，比如PPP，SLIP)**，**以太网协议需要知道目的IP 地址的物理地址，需要ARP 协议。**

#### 每层的作用：

**1 - 应用层：DNS 、HTTP 、HTTPS ：**

**应用层是体系结构中的最高层。应用层确定进程之间通信的性质以满足用户的需要。**这里的进程就是指正在运行的程序。应用层不仅要提供应用进程所需要的信息交换和远地操作，而且还要作为互相作用的应用进程的用户代理，来完成一些为进行语义上有意义的信息交换所必须的功能。应用层直接为用户的应用进程提供服务

**2 - 传输层：TCP、UDP：**

**传输层的任务就是负责主机中两个进程之间的通信。**因特网的传输层可使用两种不同协议：即面向连接的传输控制协议TCP，和无连接的用户数据报协议UDP。面向连接的服务能够提供可靠的交付，但无连接服务则不保证提供可靠的交付，它只是“尽最大努力交付”。这两种服务方式都很有用，备有其优缺点。在分组交换网内的各个交换结点机都没有传输层。

**3 - 网络层：IP、ARP：**

**网络层负责为分组交换网上的不同主机提供通信。**在发送数据时，网络层将运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP 体系中，分组也叫作IP 数据报，或简称为数据报。网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够交付到目的主机。

**4 - 数据链路层：**

**当发送数据时，数据链路层的任务是将在网络层交下来的IP 数据报组装成帧，在两个相邻结点间的链路上传送以帧为单位的数据。**每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制、以及流量控制信息等）。控制信息使接收端能够知道—个帧从哪个比特开始和到哪个比特结束。控制信息还使接收端能够检测到所收到的帧中有无差错。

**5 - 物理层：**

**物理层的任务就是透明地传送比特流。**在物理层上所传数据的单位是比特。传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆等，并不在物理层之内而是在物理层的下面。因此也有人把物理媒体当做第0 层。



### 30 - HTTPS的工作过程？

HTTPS协议 = HTTP协议 + SSL/TLS协议

SSL(Secure Socket Layer 安全套接层)

TLS(Transport Layer Security 安全传输层协议)

由于HTTPS的推出受到了很多人的欢迎，在SSL更新到3.0时，IETF对SSL3.0进行了标准化，并添加了少数机制(但是几乎和SSL3.0无差异)，标准化后的IETF更名为TLS1.0(Transport Layer Security 安全传输层协议)，即 **TLS就是SSL的3.1新版本**



<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210914105413736.png" alt="image-20210914105413736" style="zoom:67%;" />

1、浏览器往服务器的443端口发起请求，请求里携带了浏览器支持的加密算法和哈希算法。

2、服务器收到请求，选择浏览器支持的加密算法和哈希算法，并将自己的身份信息（地址等）以证书的形式发送给浏览器，

3、客户端收到网站的证书之后要：

- 验证证书的合法性
- 如果验证通过，浏览器会生成一个随机数R，并用证书中的公钥进行加密，将加密的R传送给服务器

4、服务器接收客户端传来的信息：

- 用自己的私钥解密得到R，再用以R为密钥使用**对称加密算法**加密网页内容并传输给浏览器。

5、客户端以R为密钥使用之前约定好的解密算法获取网页内容



### 31 - HTTP 和 HTTPS 的区别？

#### HTTP 和 HTTPS的基本概念

- **超文本传输协议（Hyper Text Transfer Protocol，HTTP）：**是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从**WWW服务器**传输超文本到**本地浏览器**的传输协议，它可以使浏览器更加高效，使网络传输减少。
- **HTTPS （全称：Hyper Text Transfer Protocol over SecureSocket Layer）：**是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。
  - HTTPS协议的主要作用可以分为两种：
    - 一种是建立一个信息安全通道，来保证数据传输的安全；
    - 另一种就是确认网站的真实性。

#### HTTPS 和 HTTP 的区别主要如下：

- **开销：**HTTPS协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。
- **端口不同：**HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
- **安全性：**HTTP的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。
- **资源消耗：**HTTP是超文本传输协议，信息是明文传输；HTTPS则是具有安全性的SSL加密传输协议，需要消耗更多的CPU和内存资源
- **在OSI模型中，HTTP工作于应用层，而HTTPS工作于传输层；**



### 33 - HTTPS的优缺点？

#### HTTPS 优点：

- HTTPS 传输数据过程中使用密钥进行加密，所以**安全性更高**
- HTTPS 协议可以认证用户和服务器，**确保数据发送到正确的用户和服务器**

#### HTTPS 缺点：

- **HTTPS 握手阶段延时较高：**由于在进行HTTP 会话之前还需要进行SSL 握手，因此HTTPS 协议握手阶段延时增加

- **HTTPS 部署成本高：**一方面HTTPS 协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS 协议需要进行加解密的计算，占用CPU 资源较多。



### 34 - 什么是数字签名？

为了避免数据在传输过程中被替换，比如黑客修改了报文内容，但是用户并不知道，所以需要让发送端做一个数字签名，把数据的摘要信息进行一个加密，比如MD5，得到一个签名，和数据一起发送。然后接收端把数据摘要进行MD5加密，如果和签名一样，则说明数据是正确的



### 35 - 什么是数字证书？

对称加密中，双方使用公钥进行解密。虽然数字签名可以保证数据不被替换，但数据是由公钥加密的，如果公钥也被替换，则仍然可以伪造数据，因为用户不知道对方提供的公钥是真是假。**为了保证发送方的公钥是真的，CA证书机构会负责颁发一个证书，里面的公钥确保是真的，**用户请求服务器时，服务器将证书给用户，这个证书是经由系统内置证书的备案过的。



### 36 - 谈谈你对停止等待协议（数据链路层）的理解？

停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认，在收到确认后再发下一个分组。在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。主要包括以下几种情况：

- 无差错情况
- 出现差错情况（超时重传）
- 确认丢失和确认迟到



### 37 - 谈谈你对ARQ协议（数据链路层）的理解？

#### 自动重传请求协议 ARQ

停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传之前发过的分组。因此每发送完一个分组就需要设置一个超时计时器，其重传时间应该比数据在分组传输的平均往返时间更长一些。这种自动重传方式称为自动重传请求ARQ

#### 连续ARQ协议

连续ARQ可提高信道利用率。发送方维持一个发送窗口，凡是位于窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止是所有分组都已经正确收到。



### 38 - ARP协议（地址转换协议）的工作原理

ARP协议完成了IP地址与物理地址的映射。

ARP（地址解析）协议是一种解析协议，本来主机是完全不知道这个IP对应的是哪个主机的哪个接口，当主机要发送一个IP包的时候，会首先查一下自己的ARP高速缓存表（最近数据传递更新的IP-MAC地址对应表），如果查询的IP－MAC值对不存在，那么主机就向网络广播一个ARP请求包，这个包里面就有待查询的IP地址，而直接收到这份广播的包的所有主机都会查询自己的IP地址，如果收到广播包的某一个主机发现自己符合条件，那么就回应一个ARP应答包（将自己对应的IP-MAC对应地址发回主机），源主机拿到ARP应答包后会更新自己的ARP缓存表。源主机根据新的ARP缓存表准备好数据链路层的的数据包发送工作。



### 39 - DNS的解析过程？

- 请求一旦发起，若是chrome浏览器，先在浏览器找之前有没有缓存过的域名所对应的IP地址，有的话，直接跳过dns解析，若是没有，就会找硬盘的hosts文件，查找hosts文件中是否有对应的IP地址
- 如果本地的hosts文件没有对应的IP地址，浏览器会发出一个DNS请求到本地DNS服务器，本地DNS服务器一般是网络接入服务器商提供，比如中国电信，中国移动等。
- 查询输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是**递归查询**。如果没有，本地DNS服务器还要向DNS根服务器进行查询。
- 根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：”你下一步应当向哪一个域名服务器进行查询。”然后让本地服务器进行后续的查询。本地DNS服务器继续向域服务器发出请求，比如请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。
- 最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。



1. **主机向本地域名服务器的查询一般都是采用递归查询。**

2. **本地域名服务器向根域名服务器的查询是迭代查询。**



### 40 - 谈谈你对域名缓存的了解？

为了提高DNS查询效率，并减轻服务器的负荷和减少因特网上的DNS查询报文的数量，在域名服务器中广泛应用了高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录



### 41 - IP地址有哪些分类？

A类地址（1~126）：网络号占前8位，以0开头，主机号占24位

B类地址（128~191）：网络号前16位，以10开头，主机号占后16位

C类地址（192~223）：网络号前24位，以110开头，主机号占后8位

D类地址（224~239）：以1110开头，保留位多播地址

E类地址（240~255）：以1111开头，保留位今后使用



### 42 - 特殊网络地址：

（1）**127.0.0.1**：

127是一个保留地址，该地址是指电脑本身，主要作用是预留下作为测试使用，即Windows下的localhost

（2）**10.\*.\*.\*，172.16.\*.\*――172.31.\*.\*，192.168.\*.\***：

上面三个网段是私有地址，可以用于自己组网使用，这些地址主要用于企业内部网络中，但不能够在Internet网上使用

（3）**0.0.0.0**

它表示的是这样一个集合，所有不清楚的主机和目的网络。这里的不清楚是指在本机的路由表里没有特定条目指明如何到达。

（4）**255.255.255.255**

受限制的广播地址

（5）**224.0.0.0—239.255.255.255**

这是一组组播地址，需要注意它与广播地址的区别，其中224.0.0.1特指所有的主机，224.0.0.2特指所有的路由器，224.0.0.5指所有的OSPF路由器地址，224.0.0.13指PIMV2路由器的地址。



### 43 - 什么是SQL注入？举个例子

SQL注入就是通过SQL命令插入到 **Web表单提交** 或 **输入域名** 或 **页面请求的字符串**，最终达到欺骗服务器执行恶意的SQL命令。

如果在一个登录界面，要求输入用户名或密码，可以这样输入：

```
用户名：'or 1 = 1 --
密码：
```

从理论上来说后台会验证如下SQL语句：

```java
String sql = "select * from user_table where username= ' " + userName +" ' and password='" +password +" ''";
```

当输入上面的用户名后，SQL语句变为

```sql
SELECT * FROM user_table WHERE username = '' or 1 = 1 -- and password=' '
```

此语句一定可以执行成功，后面密码编程注释。用户轻易骗过系统，获取合法身份



**解决方法：使用正则表达式过滤传入参数**



### 44 - 什么是XSS攻击？

XSS攻击是指恶意攻击者利用网站没有对用户提交数据进行转义处理或过滤不足的缺点，进而添加一些脚本代码嵌入到web页面中去，使别的用户访问都会执行相应的嵌入代码，从而盗取用户资料、利用用户身份进行某种动作或对访问者进行病毒侵害的一种攻击方式



### 45 - Cookie 和 Session 有什么区别？

1、由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要某种机制来识别具体的用户，这个机制就是Session。典型的应用场景：购物车

​		当点击下单按钮时，由于HTTP是无状态的，所以并不知道是哪个用户操作 的，所以服务端要为特定的用户创建特点的Session，用于标识这个用户，并跟踪这个用户，才知道其购物车中的物品

​		Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有，集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候Session信息都是放在内存的，使用一些缓存服务比如Memcached之类的来存放。

2、那服务端如何识别特定用户？这时需要用到Cookie。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用Cookie来实现Session追踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要**在Cookie里面记录一个Session ID**，以后每次请求把这个会话ID发送到服务器，服务器就能识别特定用户了。

3、Cookie可以保存账号信息，访问网站的时候，网站页面的脚本可以读取这个信息，自动填写用户名

**总结：**

- **Session是在服务端保存的一个数据结构，用来追踪用户的状态，**这个数据可以保存在集群、数据库、文件中。
- **Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，**也是实现Session的一种方式



### 46 - Session的工作原理？

Session的工作原理是客户端登录完成之后，服务器会创建对应的Session，Session创建完之后，会把Session的ID发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着SessionID，服务器拿到SessionID之后，在内存找到与之对应的Session 这样就可以正常工作了。



### 47 - Udp如何实现可靠性

- 1.udp可以增加消息编号；
- 2.对每个消息编号提供ACK，在udp应用层增加应答机制；
- 3.没有应答的增加重传机制
- 4.增加缓存，ACK完的才从缓存中清除