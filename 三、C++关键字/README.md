## 三、关键字：

### 1 - static关键字的作用是什么？

- 修饰局部变量时：
  - 使得该变量在静态存储区（全局区）分配内存；
  - 只能在首次函数调用中进行首次初始化，之后的函数调用不再进行初始化；
  - 生命周期与程序相同，作用域就是局部作用域。
- 修饰全局变量时：
  - 使得该变量在静态存储区（全局区）分配内存；
  - 在声明该变量的整个文件都是可见的，但在文件外是不可见的
- 修饰函数时：
  - 在声明该函数的整个文件都是可见的，但在文件外是不可见的
- 修饰成员变量时：
  - **所有的对象都只维持一份拷贝，可以实现不同对象间的数据共享；**
  - **不需要实例化对象即可访问**
  - **注意不能再类内部初始化！要在类外部初始化，初始化时不加static！**
- 修饰成员函数时：
  - 这个函数不接受this指针，**只能访问类的静态成员**
  - 这个函数不需要实例化对象即可访问



### 2 - C语言的 static 和 C++ 的 static 有什么区别？

- C中的static用来修饰局部静态变量和外部静态变量、函数
- C++中除了C中的功能以外，还可以同来定义类的成员变量和成员函数。（即静态成员和静态函数）



### 3 - cosnt的作用是什么？

**const用法小结：**

- 阻止一个变量被改变，可以使用const关键字。在定义该const变量时，需要对它进行初始化，因为以后就没有机会再去改变它了； 由于const类型变量必须定义的时候进行初始化，因此也导致**如果类的成员变量有const类型的变量，那么该变量必须在类的初始化列表中进行初始化；** 
- 对指针来说，可以指定指针本身为const（顶层const），也可以指定指针所指的数据为const（底层const），或二者同时指定为const；  
- 在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；  
- 对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量，类的常对象只能访问类的常成员函数；  
- 对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。即返回的对象在以后的使用中不能被修改
- const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员；非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；
  - **主要是非const成员函数不能访问const对象的任意数据成员**
- 一个没有明确声明为const的成员函数被看作是将要修改对象中数据成员的函数，而且编译器不允许它为一个const对象所调用。因此**const对象只能调用const成员函数。**
- const类型变量可以通过类型转换符const_cast将const类型转换为非const类型；
- 对于函数值传递的情况，因为参数传递是通过复制实参创建一个临时变量传递进函数的，函数内只能改变临时变量，但无法改变实参。则这个时候无论加不加const对实参不会产生任何影响。但是在引用或指针传递函数调用中，因为传进去的是一个引用或指针，这样函数内部可以改变引用或指针所指向的变量，这时const 才是实实在在地保护了实参所指向的变量。因为在编译阶段编译器对调用函数的选择是根据实参进行的，所以，**只有引用传递和指针传递可以用是否加const来重载**。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来。

**常量存放在内存的什么位置？**

- 局部对象：常量存放在栈区
- 全局对象：常量存放在静态存储区（全局区）
- 字面值常量：常量存放在常量区

**同时定义两个函数，一个带const，一个不带，会有问题吗？**

不会，相当于函数的重载

**参数列表里的const重载：**

```cpp
#include <iostream>
using namespace std;

void fun(const int &i)
{
    cout << "fun(const int &) called  " << endl;
}
void fun(int &i)
{
    cout << "fun(int &) called " << endl;
}
int main()
{
    const int i = 10;
    int a = 20;
    fun(i);
    fun(a);
    return 0;
}
```

输出：

```
fun(const int &) called
fun(int &) called
```

**const常函数的重载：**

```cpp
#include<iostream>  
using namespace std;  
   
class Test  
{  
protected:  
    int x;  
public:  
    Test (int i):x(i) { }  
    void fun() const  
    {  
        cout << "fun() const called " << endl;  
    }  
    void fun()  
    {  
        cout << "fun() called " << endl;  
    }  
};  
   
int main()  
{  
    Test t1 (10);  
    const Test t2 (20);  
    t1.fun();  
    t2.fun();  
    return 0;  
}
```

输出：

```
fun(const int &) called
fun(int &) called
```

**const修饰成员函数的目的是什么？**

- const修饰成员函数表明函数调用不会对对象做出任何更改，如果确定不会对对象做出更改，就应该为函数加上const限定，这样无论const对象还是普通对象都可以调用该函数。

```cpp
const Stock & Stock::topval (const Stock & s) const
```

第一个const：确保返回的Stock对象在以后的使用中不能被修改。

第二个const：确保此方法不修改传递的参数s

第三个const：**保证此方法不修改调用它的对象，const对象只能调用const成员函数，不能调用非const函数。**



### 4 - this 有什么作用？

- 一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。

- this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。



### 5 - inline 对于一个频繁使用的短小函数，应该使用什么来实现？有什么优缺点？

应该使用 inline 内联函数，即编译器将 inline 内联函数内的代码替换到函数被调用的地方。

优点在于：

- 在内联函数被调用的地方进行展开，可以省去函数调用的时间，提高程序运行效率。
- 相比于宏函数，内敛函数在代码展开时，编译器会做语法安全检查或数据类型转换，更安全。

缺点是：

- 代码膨胀，开销变大
- 如果内联函数内代码块的执行时间比调用时间长得多，那效率就没什么提升了。
- 如果修改内联函数，那么所有调用该函数的代码文件都要重新编译。

还有一点，内联声明只是建议，是否内联是由编译器决定的，并不是可控的



### 6 - 虚函数可以是内联函数吗？

- 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。



### 7 - assert 怎么用？

**断言，是宏，而非函数**

assert 宏的原型定义在 C、C++中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include 之前。

```cpp
#include <stdio.h> 
#include <assert.h> 

int main() 
{ 
    int x = 7; 
    /*  Some big code in between and let's say x is accidentally changed to 9  */
    x = 9; 
    // Programmer assumes x to be 7 in rest of the code 
    assert(x == 7); 
    /* Rest of the code */
    return 0; 
} 
```

输出：可以看到输出会把源码文件，行号错误位置，提示出来！

```cpp
assert: assert.c:13: main: Assertion `x==7' failed.
```

断言主要用于检查逻辑上不可能的情况。例如，它们可用于检查代码在开始运行之前所期望的状态，或者在运行完成后检查状态。与正常的错误处理不同，断言通常在运行时被禁用。忽略断言，可以在代码开头加上：

```cpp
#define NDEBUG          // 加上这行，则 assert 不可用
```



### 8 - explicit 有什么作用？

- explicit 修饰构造函数时，可以防止隐式转换和复制初始化
- explicit 修饰转换函数时，可以防止隐式转换，但按语境转换除外



### 9 - friend的作用？

友元提供了一种 **普通函数或者类成员函数**  访问  **另一个类中的私有或保护成员** 的机制。也就是说有两种形式的友元：

（1）友元函数：普通函数 访问 某个类中的私有或保护成员。

（2）友元类：类A中的成员函数  访问  类B中的私有或保护成员

优点：提高了程序的运行效率。

缺点：破坏了类的封装性和数据的透明性。

总结： - 能访问私有成员 - 破坏封装性 - 友元关系不可传递 - 友元关系的单向性 - 友元声明的形式及数量不受限制



### 10 - volatile 有什么作用？

- volatile提醒编译器它所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会**直接从变量地址中读取数据。**如果没有volatile关键字，则编译器可能优化读取和存储，**可能暂时使用寄存器中的值，**如果这个变量由别的程序更新了的话，将出现不一致的现象，



### 11 - 一个参数可以既是 const 又是 volatile 的吗？

可以，用cosnt 和 volatile 同时修饰变量，表示**这个变量在程序内部是只读的，**只在程序外部条件变换下改变，并且编译器不会优化这个变量。每次使用此变量时，都要去从内存读取，而不是去寄存器读取它的备份。

**const只是不允许程序中的代码改变某一变量，只在编译时发挥作用，并没有实际地禁止某段内存的读写特性。**



### 12 - define 和 typedef 有什么区别？

- 用法不同：typedef 用来定义一种数据类型的别名，增强程序的可读性；define主要用来定义常量，或者用来实现复杂但频繁使用的宏

- 执行时间不同：**typedef是编译过程的一部分**，有类型检查功能。**define是宏定义**，是预编译的部分，发生在编译前，只做简单的替换，不进行类型检查。

- 作用域不同：typedef有作用域限定。define不受作用域约束，只要是在define声明后的引用都是对的



### 13 - 说一说强制类型转换运算符？

#### static_cast

能进行基础类型之间的转换，也是最常看到的类型转换。不执行运行时类型检查，它主要的用法有：

- 用于类层次结构中父类和子类之间指针或引用的转换。进行向上转换（把子类的指针或引用转换成父类表示）是安全的；进行向下转换（把父类指针或引用转换成子类指针或引用）时，由于没有动态类型检查，所以是不安全的；

- 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。

- 可以把任何类型的表达式转换成void类型；也可以把void指针转换成目标类型的指针，但是不安全！

#### dynamic_cast 

- 主要用于在类的继承层次之间进行类型转换，它既允许向上转型（Upcasting），也允许向下转型（Downcasting）。向上转型是无条件的，不会进行任何检测，所以都能成功，**主要用于向下转型，它能安全地将指向基类的指针转换为指向子类的指针或引用，并获知转型动作成功是否。**转型失败会返回nullptr（转型对象为指针时）或抛出异常bad_cast（转型对象为引用时）。
- dynamic_cast 会动用**运行时类型识别（Run-Time Type Identification）**来进行类型安全检查，因此 dynamic_cast 存在一定的效率损失。在这一点上，static_cast 在编译期间完成类型转换，能够更加及时地发现错误。
  - **当使用dynamic_cast时，该类型必须含有虚函数，这是因为dynamic_cast使用了存储在虚函数表中的信息来判断实际的类型，**

```cpp
dynamic_cast <newType> (expression)
```

newType 和 expression 必须同时是指针类型或者引用类型。换句话说，dynamic_cast 只能转换指针类型和引用类型，其它类型（int、double、数组、类、结构体等）都不行。

#### const_cast

const_cast 用来修改类型的const或volatile属性。需要特别注意的是const_cast不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用。	

```cpp
#include <iostream>
using namespace std;

int main(){
    const int n = 100;
    int *p = const_cast<int*>(&n);
    *p = 234;
    cout<<"n = "<<n<<endl;
    cout<<"*p = "<<*p<<endl;

    return 0;
}
```

运行结果：

```
n = 100
*p = 234
```

`&n`用来获取 n 的地址，它的类型为`const int *`，必须使用 const_cast 转换为`int *`类型后才能赋值给 p。由于 p 指向了 n，并且 n 占用的是栈内存，有写入权限，所以可以通过 p 修改 n 的值。

为什么通过 n 和 *p 输出的值不一样呢？是因为 C++ 对常量的处理更像是编译时期的`#define`，是一个值替换的过程，代码中所有使用 n 的地方在编译期间就被替换成了 100。即 `cout<<"n = "<<100<<endl;`

#### reinterpret_cast

reinterpret_cast 仅仅是对二进制位的重新解释，它可以把某种指针改为其他类型的指针 ，比如它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。



### 14 - RTTI是什么？原理是什么？

RTTI（Run-Time Type Identification)，通过  运行时类型信息  程序能够  使用基类的指针或引用  来检查  这些指针或引用  所指的对象的实际派生类型。

RTTI提供了以下两个非常有用的操作符：

- typeid 操作符，返回指针和引用所指的实际类型。
- dynamic_cast 操作符，将基类类型的指针或引用安全地转换为派生类型的指针或引用。



### 15 - 说一说 extern ”C“ ?

extern “C" 的主要作用是为了能够实现C++代码调用其他C语言代码。

加上 extern “C" 后，会指示编译器这部分代码按C语言的方式进行编译。举个例子，C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名，这就是C和C++在编译上的区别。

因为C++出现以前，很多代码是C写的，而且很底层的库也是C写的，为了更好的支持原来的C代码和已经写好的C库，需要在C++中尽可能的支持C，extern ”C"就是其中一个策略

- C++代码调用C语言代码
- 在C++的头文件中使用
- 在多人协同开发时，有人擅长C有人擅长C++，也会用到



### 16 - #define 和 const 有什么区别？

主要有四点

- 第一，编译器处理方式不同：`#define`宏是在预处理阶段展开，不能对宏定义进行调试，而 `const` 常量是在编译阶段使用。
- 第二，类型和安全检查不同：`#define` 宏没有类型，不做任何类型检查，不安全，而`const`常量有具体的类型，在编译阶段会执行类型检查，更安全。
- 第三，存储方式不同：`#define` 宏仅仅是代码展开，在多个地方进行字符串替换，不会分配内存，存储于程序的代码段中，而`const`常量会分配内存，但只维持一份拷贝，存储于程序的数据段中。
- 第四，定义域不同：`#define`宏不受定义域限制，而`const`常量只在定义域内有效。



### 17 - include头文件的顺序以及双引号“ ” 和 < > 的区别？

#### Include 头文件的顺序：

对于`include `的头文件来说，如果在文件`a.h` 中声明一个在文件`b.h`中定义的变量，而不引用`b.h`。那么要在`a.c `文件中引用`b.h `文件，并且要先引用`b.h`，后引用`a.h`, 否则会报变量类型未声明错误。

**双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。**

- 对于使用**尖括号**包含的头文件，编译器只在**系统默认目录**或**尖括号内的工作目录**下搜索头文件，并不去用户的工作目录下寻找，所以一般**尖括号用于包含标准库文件**；
- 对于使用**双引号**包含的头文件，编译器先在**用户的工作目录下搜索头文件**，如果搜索不到则到系统默认目录下去寻找，所以双引号一般用于包含用户自己编写的头文件。
- 两者的不同之处在于 **双引号包含** 会先搜索用户的当前物件所在路径，后续搜索顺序是一样的，即：
  - 1. 编译器设置的头文件路径（在使用`g++`等编译器时可使用`-I`参数显式指定搜索路径）
  - 2. 系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径



### 18 - 简述 #ifdef、#else、#endif、#ifndef的作用？

#### 作用一：条件编译

一般情况下，源程序中所有的行都参加编译。但是有时希望对其中一部分内容只在满足一定条件才进行编译，也就是对一部分内容指定编译的条件，这就是“条件编译”。有时，希望当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。

```
#ifdef 标识符
程序段 1
#else 
程序段 2
#endif
```

它的作用是：当标识符已经被定义过(一般是用#define命令定义)，则对程序段1进行编译，否则编译程序段2。 

#### 作用二：避免文件重定义

在一个大的软件工程里面，可能会有多个文件同时包含一个头文件，当这些文件编译链接成一个可执行文件上时，就会出现大量“重定义”错误。在头文件中使用`#define`、`#ifndef`、`#ifdef`、`#endif`能 **避免头文件重定义。**

