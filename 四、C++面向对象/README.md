## 四、面向对象：

### 1 - 面向对象的三大特征是那些？各自有什么特点？

- 封装：将客观事物封装成抽象的类，隐藏对象的属性和实现细节，仅对外公开接口。类可以把自己的数据和方法暴露给可信的类或对象，对不可信的类或对象则进行信息的隐藏。
- 继承：继承就是子类继承父类的特征和行为，子类可以使用父类的所有功能，并且无需重新编写原来的类即可对功能进行扩展。
- 多态：一个类实例的相同方法在不同情形下有不同的表现形式，使不同内部结构的对象可以共享相同的外部接口。



### 2 - 多态的实现有哪几种？

多态分为静态多态和动态多态：

- 静态多态是通过重载和模板技术实现的，在编译期间就确定了
- 动态多态是通过虚函数和继承关系实现的，执行动态绑定，在运行期间才确定
  - 举例说明：一个父类类型的指针指向一个子类对象的时候，在父类中声明成带有`virtual关键字`的函数，在子类中重写时候不需要加`virtual`也是虚函数。



### 3 - 静态函数和虚函数的区别

静态函数在编译时就已经确定了运行时机，而虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销。



### 4 - 动态多态有什么作用？有哪些必要条件？

动态多态可以：

- 隐藏代码实现的细节，使代码模块化，提高代码的可复用性
- 使接口得到重用，让派生类的功能可以被基类的指针或引用所调用，也就是说可以向后兼容，提高了代码的可扩展性和可维护性。

动态多态的必要条件有三个：

- 需要有继承
- 需要有虚函数的覆盖
- 需要有基类的指针或引用指向子类对象

**多态例子：**

```cpp
#include <iostream>
using namespace std;

class Animal
{
public:
    virtual void makeSound() { cout << "rawr" << endl; }
};

class Dog : public Animal
{
public:
    virtual void makeSound() {cout << "bark" << endl;}
};

int main()
{
    Animal animal;
    animal.makeSound(); // (1) rawr 

    Dog dog;
    dog.makeSound();  // (2) bark
    
    Animal &doge = dog;
    doge.makeSound();   // (3) bark !!

    Animal badDog = Dog();
    badDog.makeSound();  // (4) rawr !!!

    Animal* goodDog = new Dog();
    goodDog->makeSound();  // (5) bark !!
    
}
```

定义了一个`Animal`类，派生类`Dog`，如果不使用指针或引用，`badDog`的类型永远是`Animal`类型，而不会是别的类型。`Animal badDog = Dog()`将一个新的`Dog`对象复制到`badDog`, 由于`badDog`只是`Animal`类型，只会将`Dog`对象进行切片，取属于`Animal`的部分，称为切片(slicing)。



### 5 - 动态绑定是如何实现的？

当编译器发现类中有虚函数时，会创建一张虚函数表，把虚函数的函数入口地址放到虚函数表中，并且在对象中增加一个虚函数表的指针，这个指针指向虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为本身重写的函数的地址，这样就能调用子类中覆盖后的虚函数了，实现了动态绑定。

使用虚函数，会增加访问内存开销，降低一定的效率。



### 6 - 对虚函数和多态的理解？

- 多态的实现主要分为 **静态多态** 和 **动态多态** ：
  - 静态多态主要是重载，在编译的时候已经确定；
  - 动态多态是用虚函数机制实现，在运行期间动态绑定。
  - 举例说明：一个父类类型的指针指向一个子类对象的时候，在父类中声明成带有`virtual关键字`的函数，**在子类中重写时候不需要加`virtual`也是虚函数。**
- **虚函数实现多态：**在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为本身重写的函数的地址。使用虚函数，会增加访问内存开销，降低一定的效率。



### 7 - 纯虚函数有什么作用？如何实现？起什么作用？

定义纯虚函数是为了实现一个接口，起到规范的作用，想要继承这个类就必须覆盖该函数。

```cpp
class A
{
public:
   void f(){}  //--->普通成员函数
public：
   virtual void f1(void){...}  //---> 虚函数
   virtual void f2(void) = 0;    //---> 纯虚函数
};
```

- **纯虚函数没有函数体，只有函数声明，**在虚函数声明的结尾加上`=0`，表明此函数为纯虚函数。

- **包含纯虚函数的类称为抽象类（Abstract Class）**。之所以说它抽象，是因为它**无法实例化**，也就是无法创建对象。原因很明显，纯虚函数没有函数体，不是完整的函数，无法调用，也无法为其分配内存空间。

```cpp
int main()
{
  A a;//--->错误
  return 0;
}
```

- 抽象类通常是作为基类，让派生类去实现纯虚函数。**派生类必须实现纯虚函数才能被实例化。**

```cpp
class B:public A
{
public：
   f2(void){
      //do something 
	}
};
int main()
{
  B b;//--->正确
  return 0;
}
```



### 8 - 如何让一个类不能实例化？

将类定义为抽象类（也就是存在纯虚函数）

或者将构造函数声明为 private



### 9 - 虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？

**虚函数表是针对类的，类的所有对象共享这个类的虚函数表，**因为每个对象内部都保存了一个指向该类虚函数表的指针vptr，每个对象的vptr的存放地址都不同，但都指向同一个虚函数表。



### 10 - 构造函数可以是虚函数吗？

一句话来说就是：虚函数的调用依赖于虚函数表，而指向虚函数表的指针vptr需要在构造函数中进行初始化，所以无法调用定义为虚函数的构造函数，这是一个悖论。

详细来说：

- 从存储空间角度，虚函数对应一个指向vftable虚函数表的指针，这个指针是存储在对象的内存空间上的。如果构造函数是虚函数，就必须通过vftable调用，但是对象还没有实例化，连内存空间还没有，更没有vftable，所以构造函数不能是虚函数。
- 从使用角度上，虚函数主要用于在信息不全的情况下，能够使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义。另外，虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数，从而实现多态，也就是实现一个接口，多种方法。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此规定构造函数不能是虚函数。
- A virtual call is a mechanism to get work done given partial information. In particular, "virtual" allows us to call a function knowing only an interfaces and not the exact type of the object. To create an object you need complete information. In particular, you need to know the exact type of what you want to create. Consequently, a "call to a constructor" cannot be virtual.  —— Bjarne
  - 虚拟函数调用只需要“部分的”信息，即只需要知道函数接口，而不需要对象的具体类型。但是构建一个对象，却必须知道具体的类型信息。如果你调用一个虚拟构造函数，编译器怎么知道你想构建是继承树上的哪种类型呢？所以这在逻辑上是一个悖论



### 11 - 为什么基类的析构函数一般写为虚函数？

为了实现动态绑定，基类指针指向派生类对象，如果析构函数不是虚函数，那么对象在销毁时，就会调用基类的机构函数，只能销毁派生类对象中的一部分数据，所以必须将析构函数定义为虚函数，这样销毁对象的时候就调用派生类的析构函数了，从而销毁派生类对象中的所有数据。



### 12 - 为什么C++默认的析构函数不是虚函数？

- C++默认的析构函数不是虚函数是因为**虚函数需要额外的虚函数表和虚表指针，占用额外的内存**。而对于不会被继承的类来说，析构函数如果是虚函数会浪费内存。因此C++默认的析构函数不是虚函数，只有当需要被当做父类时，设置为虚函数。



### 13 - 构造函数和析构函数能抛出异常吗？

- 从语法的角度来说，构造函数可以抛出异常，但从逻辑和风险控制的角度来说，尽量不要抛出异常，否则可能会导致内存泄露
- **析构函数不能抛出异常，如果析构函数抛出异常，则异常点后的程序，比如释放内存等操作，就不会被执行，**从而造成内存泄露的问题。而当异常发生时，C++通常会调用对象的析构函数来释放资源，如果此时析构函数也抛出异常，即前一个异常未处理又出现了新的异常，会造成程序崩溃。



### 14 - C++中析构函数的作用

- 析构函数与构造函数相反，当对象结束其生命周期，如对象所在的函数已经调用完毕时，系统会自动执行析构函数。析构函数往往用来做“清理善后” 的工作，比如释放对象分配的内存空间。
- 析构函数特点：
  - 与类名相同，函数名前加 `~`。
  - 不带任何参数，无返回值。
  - 只能用一个析构函数，不能重载。
- 如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。



### 15 - 多继承存在什么问题？如何消除多继承的二义性？

1. 多继承会增加程序的复杂度，使得程序的编写和维护比较困难，容易出错

2. 在继承时，基类之间或基类与派生类之间发生成员同名时，将出现对成员访问的不确定性，**即同名二义性；**

   **消除二义性的方法：**

   - 利用作用域运算符 `::`，用于限定派生类使用的是哪个基类的成员
   - 在派生类中定义同名成员，覆盖基类的相关成员

3. 当派生类从多个基类派生,这些基类又从同一基类派生,咋在访问此共同基类的成员时,将产生另一种不确定性,**即路径二义性:**

   **消除路径二义性的方法:**

   - 消除同名二义性的两种方法同样有用
   - 还可以使用虚继承，使得不同路径继承来的同名成员在内存中只有一份拷贝。

   

### 16 - 虚基类与虚继承是什么？

  多继承很容易产生错误，典型的就是菱形继承，是一种路径二义性的情况：

![image-20210909102027074](https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210909102027074.png)

   

在一个派生类中保留间接基类的多份同名成员，虽然可以在不同的成员变量中分别存放不同的数据，但大多数情况下这是多余的：因为保留多份成员变量不仅占用较多的存储空间，还容易产生命名冲突。假如类 A 有一个成员变量 a，那么在类 D 中直接访问 a 就会产生歧义，编译器不知道它究竟来自 A -->B-->D 这条路径，还是来自 A-->C-->D 这条路径。下面是菱形继承的具体实现： 

```cpp
//间接基类A
class A{
protected:
    int m_a;
};

//直接基类B
class B: public A{
protected:
    int m_b;
};

//直接基类C
class C: public A{
protected:
    int m_c;
};

//派生类D
class D: public B, public C{
public:
    void seta(int a){ m_a = a; }  //命名冲突
    // 因为类 B 和类 C 中都有成员变量 m_a（从 A 类继承而来），编译器不知道选用哪一个，所以产生了歧义。
    void setb(int b){ m_b = b; }  //正确
    void setc(int c){ m_c = c; }  //正确
    void setd(int d){ m_d = d; }  //正确
private:
    int m_d;
};

int main(){
    D d;
    return 0;
}
```

   利用作用域运算符 `::`消除二义性：

```cpp
void seta(int a){ B::m_a = a; } // 表示使用 B 类的 m_a，反之使用C的同理
```

**利用虚继承解决：在继承方式前面加上 virtual 关键字就是虚继承**

```cpp
//间接基类A
class A{
protected:
    int m_a;
};

//直接基类B
class B: virtual public A{  //虚继承
protected:
    int m_b;
};

//直接基类C
class C: virtual public A{  //虚继承
protected:
    int m_c;
};

//派生类D
class D: public B, public C{
public:
    void seta(int a){ m_a = a; }  //正确
    void setb(int b){ m_b = b; }  //正确
    void setc(int c){ m_c = c; }  //正确
    void setd(int d){ m_d = d; }  //正确
private:
    int m_d;
};

int main(){
    D d;
    return 0;
}
```

这段代码使用虚继承重新实现了上图所示的菱形继承，这样在派生类 D 中就只保留了一份成员变量 m_a，直接访问就不会再有歧义了。

**虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class）**，本例中的 A 就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。

![image-20210909102539106](https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210909102539106.png)

 C++标准库中的 iostream 类就是一个虚继承的实际应用案例。iostream 从 istream 和 ostream 直接继承而来，而 istream 和 ostream 又都继承自一个共同的名为 base_ios 的类，是典型的菱形继承。此时 istream 和 ostream 必须采用虚继承，否则将导致 iostream 类中保留两份 base_ios 类的成员。

![image-20210909102606304](https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210909102606304.png)





### 17 - C++的空类有哪些成员函数？

-  默认构造函数、
-  默认拷贝构造函数、
-  默认析构函数、
-  默认赋值运算符、
-  取址运算符、
-  取址运算符 const

```cpp
class Empty
{
public:
	Empty(); // 缺省构造函数
	Empty( const Empty& ); // 拷贝构造函数
	~Empty(); // 析构函数
	Empty& operator=( const Empty& ); // 赋值运算符
	Empty* operator&(); // 取址运算符
	const Empty* operator&() const; // 取址运算符 const
};
```



### 18 - 如果类A是一个空类，sizeof（A）的值是多少？为什么？

`sizeof(A)` 的值为1，因为编译器需要区分这个空类的不同实例，分配一个字节，可以使这个空类的不同实例拥有一个独一无二的地址，这样空类在实例化后在内存得到了独一无二的地址，所以空类所占的内存大小是1个字节。



### 19 - 重写和重载之间有什么区别？

- **重写是指在子类中重新定义父类的函数，子类继承父类。**父类中的函数是虚函数，在子类中重新定义了这个虚函数，其函数名、参数列表、返回类型与父类完全相同，只是函数体的实现存在区别；重写只发生在类的成员函数中。
- **重载是指两个函数具有相同的函数名，不同的参数列表，不关心返回值；**
  - 当调用函数时，根据传递的参数列表来判断调用哪个函数；
  - 重载可以是类的成员函数，也可以是普通函数



### 20 - 简述成员函数的 重载 、重写 和 隐藏 的区别：

#### 重载 、重写的区别

- 范围的区别：重载和被重载的函数在同一类中，重写和被重写的函数在两个类里
- 参数列表的区别：重载和被重载的函数列表一定不同，重写和被重写的函数列表一定相同
- virtual区别：重载和被重载函数可以被virtual修饰也可以没有。但是重写的基类中被重写的函数必须要有virtual修饰

#### 隐藏和重写、重载的区别

- **隐藏是指派生类的函数屏蔽了与其同名的基类函数，注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。**

- 范围的区别：隐藏与重载的范围不同，和重写一样，隐藏函数和被隐藏函数不在一个类中
- 参数的区别：隐藏函数和被隐藏函数的参数列表可相同也可不同，但是函数名肯定要相同。当参数不相同时，无论基类中的参数是否被virtual修饰，基类的函数都是被隐藏，而不是被重写。

#### 总结：

- **重写是动态绑定的多态，重载是静态绑定的多态**



### 21 - 拷贝构造函数和赋值运算符重载之间有什么区别？

- 拷贝构造函数用于构造新的对象

```cpp
Student s;
Student s1 = s;  // 隐式调用拷贝构造函数
Student s2(s);   // 显示调用拷贝构造函数
```

- 赋值运算符重载用于将源对象的内容拷贝到目标对象中，而且若源对象中包含未释放的内存需要先将其释放

```cpp
Student s1;
Student s2;
s2 = s1; // 使用赋值运算符
```

一般情况下，类中包含指针变量时，需要重载拷贝构造函数、赋值运算符和析构函数



### 22 - 为什么拷贝构造函数必须传引用不能传值？

拷贝构造函数的作用就是用来复制对象的，使用这个对象的实例来初始化这个对象的一个新的实例。

参数传递过程到底发生了什么？

- **将地址传递和值传递统一起来，归根结底还是传递的是"值"(地址也是值，只不过通过它可以找到另一个值)！**
- **值传递：**
  -  对于内置数据类型的传递时，直接赋值拷贝给形参(注意形参是函数内局部变量)；
  -  对于类类型的传递时，需要首先调用该类的拷贝构造函数来初始化形参(局部对象)；如`void foo(class_type obj_local){}`, 如果调用`foo(obj)`; 首先`class_type obj_local(obj)` ,这样就定义了局部变量obj_local供函数内部使用。
- **引用传递:**
  -  无论对内置类型还是类类型，传递引用或指针最终都是传递的地址值！而地址总是指针类型(属于简单类型), 显然参数传递时，按简单类型的赋值拷贝，而不会有拷贝构造函数的调用(对于类类型).

**拷贝构造函数用来初始化一个非引用类类型对象，如果用传值的方式进行传参数，那么构造实参需要调用拷贝构造函数，而拷贝构造函数需要传递实参，所以会一直递归。**

```cpp
#include<iostream>
using namespace std;
class A
{
public:
	A(){}//构造函数

	A(A p_a)//错误的拷贝构造函数
	{
		m1 = p_a.m1;
	}

	A(A&p_a)//正确的拷贝构造函数
	{
		m1 = p_a.m1;
	}
private:
	int m1;
};
int main(void)
{
	A a1;
	A a2(a1);//调用拷贝构造函数，来创建a2
}

```

如代码所示：若是传值的话 `实参a1` 传给`形参 p_a` 时，调用的还是拷贝构造函数；那相当于拷贝构造函数在执行的时候调用了自己，从而产生了一个递归，陷入死循环；
所以拷贝构造函数不能传值，而传指针和引用就不会存在这个问题



### 23 - 拷贝（复制）初始化和直接初始化，初始化和复制的区别？

- `ClassTest ct1("ab"); `属于直接初始化，它不需要调用赋值构造函数，而是直接调用构造函数 `ClassTest(const char* pc)`，所以当拷贝构造函数为私有时，它还是可以执行。
- `ClassTest ct2 = "ab";`属于拷贝初始化，它首先调用构造函数 `ClassTest(const char* pc)`创建一个临时对象，然后调用拷贝构造函数，把这个临时对象作为参数，构造对象ct2，所以当拷贝构造函数变成私有时，此语句不能编译通过。

- `ClassTest ct3 = ct1;` 属于拷贝初始化，因为ct1本来已经存在，所以不需要调用相关构造函数，而是直接调用拷贝构造函数，把它的值拷贝给对象ct3；所以当拷贝构造函数变成私有时，此语句不能编译通过。
- `ClassTest ct4(ct1);` 属于直接初始化，因为ct1本来已经存在，直接调用拷贝构造函数，生成对象ct3的副本ct4，所以当拷贝构造函数变成私有时，此语句不能编译通过。

要点就是拷贝初始化和直接初始化调用的构造函数是不一样的，但是当类进行复制时，类会自动生成一个临时的对象，然后再进行拷贝初始化。

```cpp
#include <iostream>
#include <cstring>
using namespace std;
class ClassTest
{
public:
    ClassTest()
    {
        c[0] = '\0';
        cout << "ClassTest()" << endl;
    }
    ClassTest& operator=(const ClassTest &ct)
    {
        strcpy(c, ct.c);
        cout << "ClassTest& operator=(const ClassTest &ct)" << endl;
        return *this;
    }
    ClassTest(ClassTest&& ct)
    {
        cout << "ClassTest(ClassTest&& ct)" << endl;
    }
    ClassTest & operator=(ClassTest&& ct)
    {
        strcpy(c, ct.c);
        cout << "ClassTest & operator=(ClassTest&& ct)" << endl;
        return *this;
    }
    ClassTest(const char *pc)
    {
        strcpy(c, pc);
        cout << "ClassTest (const char *pc)" << endl;
    }
    
    //private:
    ClassTest(const ClassTest& ct)
    {
        strcpy(c, ct.c);
        cout << "ClassTest(const ClassTest& ct)" << endl;
    }
private:
    char c[256];
};

int main()
{
    ClassTest ct1("ab");//直接初始化
    ClassTest ct2 = "ab";//复制初始化
    ClassTest ct3 = ct1;//复制初始化
    ClassTest ct4(ct1);//直接初始化
    ClassTest ct5 = ClassTest("ab");//复制初始化 将ct5对象地址作为实参去调用默认构造函数，进而对ct5进行初始化。
    return 0;
}
```



### 24 - C++中类成员的访问权限和继承权限问题

#### 访问权限：

- 1. **public 公有的：**该关键字修饰的成员表示公有成员，该成员不仅可以在类内可以被访问，在类外也是可以被访问的，是类对外提供的可访问接口；
- 2. **private 私有的：**用该关键字修饰的成员表示私有成员，该成员仅在类内可以被访问，在类体外是隐藏状态；
- 3. **protected 受保护的：**用该关键字修饰的成员表示保护成员，保护成员在类体外同样是隐藏状态，但是对于该类的派生类来说，相当于公有成员，在派生类中可以被访问。

#### 继承方式：

- **若继承方式是 public**，**基类成员**在派生类中的**访问权限保持不变**，也就是说，基类中的成员访问权限，在派生类中仍然保持原来的访问权限；
- **若继承方式是 private**，**基类所有成员**在派生类中的访问权限**都会变为私有**(private)权限；
- **若继承方式是 protected**，**基类的公有成员和保护成员**在派生类中的访问权限都会变为**保护(protected)权限** (public -> protected) ，私有成员在派生类中的访问权限仍然是私有(private)权限。



### 25 - C++ 中 `struct` 和 `class`  的区别：

- 在C++中，可以用 `struct` 和 `class` 定义类，都可以继承。区别在于：
  - **`struct` **的默认继承权限和默认访问权限是**public**
  - **`class`** 的默认继承权限和默认访问权限是 **private**
- `class`还可以定义模板类形参，比如`template <class T, int i>` ,而`struct`不能



### 26 - C++ 保留struct关键字的原因？

- 保证对C的向下兼容性
- 把C++中最基本的对象单元规定为class而不是struct，就是为了避免各种兼容性要求的限制
- 对struct定义的扩展使C的代码更容易移植到C++中



### 27 - C++类内可以定义引用数据成员吗？

C++类内可以定义引用成员变量，但要遵循以下三个规则：

1. 不能用默认构造函数初始化，必须提供构造函数来初始化引用成员变量。否则会造成引用未初始化错误。
2. 构造函数的形参也必须是引用类型
3. 不能在构造函数里初始化，必须在初始化列表中进行初始化。

```cpp
#include <iostream>
using namespace std;

class A
{
public:
	A(int &target) :a(target)
	{
		cout << "构造函数" << endl;
	}
	void printA()
	{
		cout << "a is:" << a << endl;
	}
private:
	int &a;
};
int main()
{
	int a = 20;
	A r(a); // 依旧使用自定义的构造函数
	r.printA();

	int &b = a;
	A r1(b);
	r1.printA();
	return 0;
}

```

输出：

```
构造函数
a is:20
构造函数
a is:20
```



### 28 - 说一说模板函数和模板类的特例化

**引入原因：**

编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化

**定义：**

对单一模板提供一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上

（1）模板函数特例化

必须为原函数模板的每个函数都提供实参，且使用关键字template后面一个空尖括号<>，表明将原模板的所有模板参数提供实参

```cpp
template<typename T> // 模板函数
int compare(const T &v1, const T &v2)
{
    if (v1 > v2) return -1;
    if (v2 > v1) return 1;
    return 0;
}

// 模板特例化，满足针对字符串特定的比较，要提供所有实参，这里只有一个T
template<>
int compare(const char* const &v1, const char* const &v2)
{
    return strcmp(p1, p2);
}
```

**本质：**特例化的本质是实例化一个模板，而非重载它。特例化不影响参数匹配。参数匹配都是以最佳匹配为原则

**注意：**模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本。

（2）类模板特例化

原理类似于函数模板，不过在类中，可以对模板进行特例化，也可以对类进行部分特例化。对类进行特例化时，仍然用 `template<>`表示是一个特例化版本：

```cpp
template<>
class hash<sales_data>
{
    size_t operator()(sales_data& s);
    
}
```

**类模板的部分特例化：**

不必为所有模板参数提供实参，可以指定一部分而非所有模板参数，一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参（特例化时类名一定要和原来的模板相同，只是参数类型不同，按最佳匹配原则）

**特例化类中的部分成员：**

可以特例化类中的部分成员函数而不是整个类

```cpp
template<typename T>
class Fo
{
    void Bar();
    void Barst(T a)();
}

template<>
void Fo<int>::Bar()
{
    cout <<"我是int型特例化"<<endl;
}

Fo<string> fs;
Fo<int> fi;
fs.Bar(); // 使用普通模板，即Fo<string>::Bar()
fi.Bar(); // 使用特例化，即Fo<int>::Bar()
```

