## 十二、数据库



### 1- 说一说对MySQL架构的了解？

MySQL可以分为 Server层 和 存储引擎两部分。

Server层：包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数字、加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。

存储引擎：负责数据的存储和提取，其架构是插件式的，支持InnoDB、MyISAM等多个存储引擎。MySQL5.5.5版本后默认存储引擎是InnoDB



### 2 - 数据库三大范式是什么？

- 第一范式——**无重复的列（原子性）：**强调的是列的原子性，数据表的每一列都是不可分割的原子数据项
- 第二范式——**要求实体的属性完全依赖于主关键字（唯一性）：**所谓完全依赖是指不能存在依赖主关键字一部分的属性
  - 第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。
- 第三范式——**任何主属性不依赖于其他非主属性（每列都与主键有直接关系，不存在传递依赖）**
  - 第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。



### 3 - 一条SQL语句在数据库框架中的执行流程？

<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20211011204851519.png" alt="image-20211011204851519" style="zoom:67%;" />

1. 应用程序把查询SQL语句发送给服务器执行；
2. 查询缓存，如果缓存是打开的，服务器在收到查询请求后，并不会直接去数据库查询，而是在数据库的查询缓存中找是否有相同的查询数据，如果存在，直接返回给客户端。只有缓存不存在时，才会进行下面的操作
3. 查询优化处理，生成执行计划。包括解析SQL、预处理、优化SQL、执行计划   
4. MySQL根据相应的执行计划完成整个查询
5. 将查询结果返回给客户端



### 4 - 谈谈你对MVCC的了解？

**MVCC（Multi-Version Concurrency Control, 多版本并发控制）**，数据库并发场景：

- 读——读：不存在任何问题，也不需要并发控制
- 读——写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读
- 写——写：有线程安全问题，可能会存在更新丢失的问题

MVCC 可以为数据库解决以下问题：

- 在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发的读写性能
- 可以解决脏读、不可重复读、幻读等事务隔离问题，但不能解决更新丢失问题。



### 5 - 查询性能的优化方法？

- 减少请求的数据量
  - 只返回必要的列：最好不要使用 SELECT * 语句
  - 只返回必要的行：使用 LIMIT 语句来限制返回的数据
  - 缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能是非常明显的
- 减少服务端扫描的行数：
  - 使用索引来覆盖查询



### 6 - 谈谈你对索引的理解？

索引的出现是为了提高数据的查询效率，就像书的目录一样。

#### 索引也会带来负面影响：

- 创建索引和维护索引需要消耗时间，这个时间随着数据量的增加而增加
- 索引需要占用物理内存，不光是表需要占用数据空间，每个索引也需要占用物理空间
- 当对表进行增删改查的时候，索引也要动态维护，降低了数据的维护速度

#### 建立索引的原则：

- 在最频繁使用的、用以缩小查找返回的字段建立索引
- 在频繁使用的、需要排序的字段上建立索引

#### 不适合建索引的情况：

- 对于查询中很少涉及的列或重复值比较多的列，不适合建立索引
- 对于一些特殊的数据类型，不适合建立索引，比如文本字段 (text)等



### 7 - 索引的分类？

- 数据结构角度
  - 树索引 $O(\log{n})$
  - Hash索引
- 物理存储角度：
  - 聚簇索引
  - 非聚簇索引
- 逻辑角度
  - 普通索引
  - 唯一索引
  - 主键索引
  - 联合索引
  - 全文索引



### 8 - 谈谈你对哈希索引的理解？

哈希索引能以 $O(1)$ 时间进行查找，但失去了有序性。无法用于排序与分组，只支持精确查找，无法用于部分查找和范围查找

InnoDB存储引擎有一个特殊功能叫 “自适应哈希索引” ，当某个索引值被使用的非常频繁时，会在B+树索引之上再创建一个哈希索引，这样就让B+Tree索引具有哈希索引的一些优点，实现快速的哈希查找



### 9 - 谈谈你对聚簇索引的理解？

- 聚簇索引是对磁盘上实际数据重新组织，然后按指定的一个或多个列的值排序的算法。

- 聚簇索引的特点是存储数据的顺序和索引顺序一致。

- 一般情况下主键会默认创建聚簇索引，而且一张表只允许存在一个聚簇索引



### 10 - 谈谈你对覆盖索引的认识？

覆盖索引是select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖。覆盖索引优点有：

- 1. 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量
- 2. 一些存储引擎（例如：MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存，因此，只访问索引可以不使用系统调用，系统调用通常比较费时
- 3. 对于InnoDB引擎，若辅助索引能够覆盖查询，则无需访问主索引



### 11 - 怎么知道创建的索引有没有被使用到？或者说怎么才可以知道这条语句运行很慢的原因？

使用Explain命令查看语句的执行计划，MySQL在执行某个语句之前，会将该语句过一遍查询优化器，之后会拿到对语句的分析，也就是执行计划，其中包含了很多信息。可以通过其中和索引有关的信息来分析是否命中了索引，例如：possible_key、key、key_len等字段，分别说明了此语句可能会使用的索引、实际使用的索引以及索引的长度



### 12 - 什么情况下索引会失效？即查询不走索引？

1、索引列参与表达式计算

```sql
SELECT 'sname' FROM 'stu' WHERE 'age' + 10 = 30;
```

2、函数运算：

```sql
SELECT 'sname' FROM 'stu' WHERE LEFT('date',4) < 1900;
```

3、%语句% 模糊查询:

```sql
SELECT * FROM 'manong' WHERE 'uname' LIKE '%码农%' -- 走索引
SELECT * FROM 'manong' WHERE 'uname' LIKE "%码农%" -- 不走索引
```

4、字符串与数字比较不走索引：

```sql
CREATE TABLE 'a' ('a' char(10));
EXPLAIN SELECT * FROM 'a' WHERE 'a' = "1"; -- 走索引
EXPLAIN SELECT * FROM 'a' WHERE 'a' = 1;   -- 不走索引，同样也是使用了函数运算
```

5、查询条件中有or，即时其中有条件带索引也不会使用

```sql
SELECT * FROM dept WHERE dname='xxx' or loc='xx' or deptno=45;
```

6、正则表达式不使用索引

7、MySQL内部优化器会对SQL语句进行优化，如果优化器估算使用全表扫描比使用索引快，则不使用索引。





### 13 - 索引的底层使用的是什么数据结构？

索引的数据结构和具体存储引擎的实现有关，常用的有Hash索引，B+树索引等

InnoDB存储引擎默认索引实现为 B+树索引



### 14 - 谈谈你对B+树的理解？

- B+树是基于B树和叶子节点顺序访问指针进行实现的，它具有B树的平衡性，并且通过顺序访问指针来提高查询的性能。
- B+树中，节点中的key从左到右非递减排列，如果某个指针的左右相邻key_i 和 key_i+1，且不为NULL，则该指针指向节点的所有key大于等于key_i且小于等于key_i+1
- 进行查找操作时，首先在根节点进行二分查找，找到一个key所在的指针，然后递归地在指针所指向的节点进行查找，直到查找到叶子节点，然后在叶子节点上进行二分查找，找出key所定义的data
- 插入、删除操作会破坏平衡树的平衡性，因此在插入删除操作后、需要对树进行一个分裂、合并、旋转等操作来维护平衡性。



### 15 - InnoDB存储引擎选用B+树而不是B树的原因？

用B+树不用B树考虑的是 IO 对性能的影响，B树的每个节点都存储数据，而B+树只有叶子节点才存储数据，所以查找相同数据量的情况下，B树的高度更高，IO更频繁。

数据库索引是存储在磁盘上的，当数据量过大时，就不能把整个索引uqanbu加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）



### 16 - InnoDB 和 MyISAM的比较？

|                         |                InnoDB                |         MyISAM         |
| :---------------------: | :----------------------------------: | :--------------------: |
|          事务           |                 支持                 |         不支持         |
|        全文索引         |                不支持                |          支持          |
| 数据量过大时使用count() | 瞬间返回，因为MyISAM会直接存储总行数 | 需要按行扫描再返回结果 |
|          外键           |                 支持                 |         不支持         |
|           锁            |       支持表锁、行锁，默认行锁       |       只支持表锁       |



### 17 - 说一下MySQL的行锁和表锁？

MyISAM只支持表锁，InnoDB支持表锁和行锁，默认为行锁。

表锁：开销小，加锁快，不会出现死锁。锁定力度大，发生锁冲突的概率高，并发度低

行锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率低，并发度最高



### 18 - 描述下事务的特性？

- 原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用
- 一致性：执行事务前后，数据从一个一致性状态转换到另一个一致性状态
- 隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的
- 持久性：一个事务被提交后。它对数据库中数据的改变是持久的，即时数据库发生故障也不应该对其有任何影响



### 19 - 什么叫脏读、不可重复读和幻读？

- 脏读：表示一个事务能够读取另一个事务中还未提交的数据。
  - 比如：某个事物尝试插入记录A，此时该事务还未提交，然而另一个事务尝试读取到了这个记录A
- 不可重复读：是指一个事务内，多次读取一个数据
- 幻读：指一个事务内多次查询返回的结果集不一样。
  - 比如：同一个事务A第一次查询的时候有n个记录，但是第二次同等条件下查询却有n+1条记录。
  - 原因：发生幻读的原因也是另外一个事务新增或删除或修改了第一个事务的结果集里的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或变少了。



### 20 - 谈谈你对事务隔离级别的理解？

**1、READ_UNCOMMITTED（未提交读）：**最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读、不可重复读

**2、READ_COMMITTED（提交读）：**允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读、不可重复读仍有可能发生

**3、REPEATABLE_READ（可重复读）：**对同一字段的多次读取结果都是一致的，除非数据是被本事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。

**4、SERIALIZABLE（串行化）：**最高隔离级别，完全服从ACID的隔离级别。所有的事务依次执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以阻止脏读、不可重读读、幻读。但是这将严重影响程序的性能，通常情况都不会使用该级别。



**ACID，**是指数据库管理系统（DBMS）在写入或更新资料的过程中，为保证事务（transaction）是正确可靠的，所必须具备的四个特性：原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability）。



### 21 - 主从复制是什么？主从复制中涉及到哪三个线程？

#### 主从复制是什么？

主从复制是用来建立一个和主数据库完全一样的数据库环境，称为从数据库；主数据库一般是实时的业务数据库，从数据库的作用和使用场合一般有几个：

- 一是作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作；
- 二是可在从数据库作备份、数据统计等工作，这样不影响主数据库的性能；

#### 主从复制中涉及到哪三个线程？

- binlog线程：负责将主服务器上的数据更改写入二进制日志（Binary log）中
- I/O线程：负责从主服务器上读取二进制日志，并写入从服务器的重放日志（Relay log）中
- SQL线程：负责读取重放日志并重放其中的SQL数据



### 22 - 谈谈你对数据库读写分离的理解？

读写分离常用代理方式实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。

读写分离能提高性能，是因为：

- 主从服务器负责各自的读和写，极大程度缓解了锁的争用
- 从服务器可以使用MyISAM，提高查询性能以及节约系统开销
- 增加冗余，提高可用性



### 23 - MySQL默认的隔离级别是什么？

MySQL：REPEATABLE_READ （repeatable_read）

ORACLE：READ_COMMITTED （read_committed）



### 24 - InnoDB 存储引擎的锁算法有哪些？

- Record Lock：单个行记录上的锁
- Gap Lock：间隙锁，锁定一个范围，不包括记录本身
- Next_key Lock： Record + Gap 锁定一个范围，包括记录本身



### 25 - MySQL问题排查都有哪些手段？

1. 使用 show processlist 命令查看当前所有连接信息
2. 使用 Explain 命令查询SQL语句执行计划
3. 开启慢查询日志，查看慢查询的SQL



### 26 - MySQL中CHAR和VARCHAR的区别？

- char的长度是不可变的，用空格填充到指定长度大小，而varchar的长度是可变的。
- char的存取速度还是要比varchar要快得多
- char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。



### 27 - 谈谈你对水平切分和垂直切分的理解？

- 水平切分

  - 水平切分是将同一个表中的记录拆分到多个结构相同的表中。当一个表的数据不断增多时，水平切分是必然的选择，它可以将数据分布到集群的不同节点上，从而缓解单个数据库的压力

- 垂直切分

  - 垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。例如：将原来的电商数据库垂直切分成商品数据库、用户数据库等。




### 28 - 存储过程的优缺点？

#### 优点

**1、重复使用。存储过程可以重复使用，从而可以减少数据库开发人员的工作量。**

**2、减少网络流量。存储过程位于服务器上，调用的时候只需要传递存储过程的名称以及参数就可以了，因此降低了网络传输的数据量。**

**3、安全性。参数化的存储过程可以防止SQL注入式攻击，**而且可以将Grant、Deny以及Revoke权限应用于存储过程。

简单讲：

1.存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译，而一般SQL语句每执行一次就编译一次,所以使用存储过程可提高数据库执行速度。

2.当对数据库进行复杂操作时(如对多个表进行Update,Insert,Query,Delete时)，可将此复杂操作用存储过程封装起来与数据库提供的事务处理结合一起使用。

3.存储过程可以重复使用,可减少数据库开发人员的工作量

4.安全性高,可设定只有某些用户才具有对指定存储过程的使用权

有一点需要注意的是，一些网上盛传的所谓的存储过程要比sql语句执行更快的说法，实际上是个误解，并没有根据，包括微软内部的人也不认可这一点，所以不能作为正式的优点，希望大家能够认识到这一点。

#### 缺点

**1、调试麻烦，**但是用 PL/SQL Developer 调试很方便！弥补这个缺点。

**2、移植问题，**数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。

**3、重新编译问题，**因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。

**4、 如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。**



### 29 - 给定a、b两个文件，各存放50亿个url，每个url占64字节，内存限制4gb，找出a、b文件共同的url

#### 思路1

先计算总数据，看看能不能一次性放到内存里：

50亿 = 5,000,000,000 约等于5G

总大小：5G * 64B = 32GB ，远大于4GB

**只能使用哈希表将文件切分成小文件**：

文件的数量怎么确定？切成小文件后，内存里需要同时 存放a和b的两个小文件，才能进行比较。那一个小文件的最大大小为2G，32/2 = 16，但是机器运行还需要内存，所以切分成20份，两个小文件占用内存3.2G，一个1.6GB

#### 思路2

**（1）对a 、b、hash(url)%20,分为20个小文件里**

hash映射函数可以有多种选择

最简单的就是按首字母分类，分成26个喜爱哦文件，但是不能保证每个文件大小相等，也不符合20个小文件的设定

**可以取前4个字节的int和%20，分配到20个小文件里**

**（2）因为使用同一个hash函数映射规则的原因，a，b切分后相同的URL存在对应的小文件里，即a0只需要和b0不急，a1和b1比较即可**

**（3）同时加载每一对小文件（如a0和b0），如果有相同的URL，则输出到文件中记录，全部比较完成后，文件中就是所有相同的记录**



### 30 - B树

![image-20210918093128242](https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210918093128242.png)

**B树（B-树）是一种平衡多路查找数，B树中所有节点的子树个数的最大值称为B树的阶，用m表示，一颗m阶的B树，如果不为空，必须满足以下特性：**

- 树中每个节点至多有m-1个关键字，有m颗子树（叶结点也算B树的子树）
- 除根节点以外，所以非叶节点至少含有 $\lceil m/2 \rceil  - 1$个关键字，即 $\lceil m/2 \rceil $ 颗子树。（根节点的关键字可以小于$\lceil m/2 \rceil -1$，可以没有子树，如果有子树，则至少有两颗）
- 所有叶节点都在同一层上（各个子树没有高度差，绝对平衡）。叶结点不带信息，可以看成查找失败的节点
- 所有非叶子节点的结构为下图：
  - 其中 $K_i(i = 1,2,3,...,n)$ 为节点的关键字，且满足 $K_1<K_2<K_3<..<K_n$，$P_i(i=0,1,2,3...,n)$ 为指向子树根节点的指针

![image-20210918094430405](https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210918094430405.png)



一颗含有n个关键字的m阶B树（最小高度和最大高度不包括叶结点）：

- 有多少个叶节点？
  - n+1
- 最小高度是多少？
  - 最胖的树最矮，让每个节点有m-1个关键字，即 $h\ge \log_m{(n+1)}$
- 最大高度是多少？
  - 最瘦的树最高，让树中每个节点有 $\lceil m/2 \rceil  - 1$个关键字 ，根节点只有一个关键字即可
  - $h \le \log_k{\frac{n+1}{2}} +1 = \log_{\lceil m/2 \rceil}{\frac{n+1}{2}}+1$



### 31 - B+树

![image-20210918112230660](https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210918112230660.png)

在B+树中查找某个关键字，可以从根节点开始，采用分块查找的方法，也可以直接从叶节点开始，采用顺序查找的方法

B+树中，上面存放索引的叫分支节点，最后一层叶结点是存放数据的

**定义：**

一颗m阶的B+树，如果不为空，就必须满足以下特性：

- 树中的每个节点至多有m个关键字，即m颗子树。（结点的关键字个数与子树数量相同）
- 除根节点外，所有非节点至少含有$\lceil m/2 \rceil$个关键字，即$\lceil m/2 \rceil$颗子树。（根节点关键字的个数可以小于$\lceil m/2 \rceil$，可以没有子树，如果有子树，则至少有两颗）。
- 所有叶节点包含了全部关键字和关键字指向记录的指针，叶节点内的关键字有序排列，叶结点之间也是有序排列，指针相连
- 所有非终端节点可以看成索引，仅包含了其子树中最大或最小关键字的值



### 32 - B树与B+树的差异

m阶的B树和B+树的差异（以5阶为例）：

（1）B+树由分块查找进化而来；B树由二叉排序树进来而来

（2）在B+树中，每个非根节点关键字的取值范围是 $3 \le n \le 5$，有n颗子树；在B树中，每个非根节点的取值范围是$2 \le n \le 4$，有n+1颗子树

（3）在B+树中，仅叶子节点包含信息，非叶子节点仅起索引作用；在B树中，全部节点的关键字都包含信息。

（4）在B+树中，叶结点包含了全部的关键字，非叶节点中出现的关键字一定会出现在叶子结点中；在B树中，任何节点的关键字都不会重复。

（5）B+树支持顺序查找和多路查找；B树只支持多路查找



### 33 - Drop、Delete、Truncate的区别

- Delete 用来删除表的全部或者一部分数据行，执行Delete之后，用户需要提交(commmit)或者回滚(rollback)来执行删除或者撤销删除，会触发这个表上所有的delete触发器。
- Truncate删除表中的所有数据，这个操作不能回滚，也不会触发这个表上的触发器，Truncate比Delete更快，占用的空间更小。
- Drop命令从数据库中删除表，所有的数据行，索引和权限也会被删除，所有的DML触发器也不会被触发，这个命令也不能回滚。

在不再需要一张表的时候，用Drop；在想删除部分数据行时候，用Delete；在保留表而删除所有数据的时候用Truncate。





### 34 - 悲观锁和乐观锁的原理以及应用场景？

#### 悲观锁

- **先获取锁，再进行业务操作**，一般就是利用类似 SELECT … FOR UPDATE 这样的语句，对数据加锁，避免其他事务意外修改数据。
- 当数据库执行SELECT … FOR UPDATE时会获取被SELECT中的数据行的行锁，SELECT FOR UPDATE获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。

#### 乐观锁

- **先进行业务操作，只在最后实际更新数据时检查数据是否被更新过** 

- Java 并发包中的AtomicFieldUpdater 类似，也是利用 CAS 机制，并不会对数据加锁，而是通过对比数据的时间戳或者版本号，来实现乐观锁需要的版本判断。

