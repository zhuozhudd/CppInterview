## 一、基础：

### 1 - C++和C有什么区别？

**在设计思想上：**

- C++是面向对象语言
- C是面向过程的结构化编程语言

**在语法上：**

- C++具有重载、继承、多态三种特性
- C++相比C，增加了许多类型安全机制，比如强制类型转换等
- C++支持范式编程，比如模板类、函数模板等



### 2 - C的结构体和C++的有什么区别？

- C的结构体不能有函数成员，但是C++的可以有
- C的结构体没有访问权限限定，C++的有private、public和protected访问限定，默认是public（为了与C兼容）（C++类中默认是private）
- C的结构体不能继承，C++的能继承，能实现多态。

具体细节：

- 1. 数据类型：
     - C 中`struct`是用户自定义数据类型`（UDT）`；
     - C++中 `struct` 是抽象数据类型`（ADT）`，支持成员函数的定义，（C++中的`struct`能继承，能实现多态）。

- 2. 权限：
     - C 中`struct`是没有权限的设置，**且`struct`中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员不可以是函数。**
     - C++中，`struct`的成员默认访问权限为`public`（为了与C兼容），`class`中的默认访问限定符为`private`，`struct`增加了访问权限，且可以和类一样有成员函数。

- 3. 声明写法：
     - `struct`作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在C中必须在结构标记前加上`struct`，才能做结构类型名
     - C++中声明时不需要加`struct`。



### 3 - C++源文件从文本到可执行文件经历的过程？

<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210919202217064.png" alt="image-20210919202217064" style="zoom: 50%;" />

对于C++源文件，从文本到可执行文件一般需要四个过程：

- **预处理阶段：**加入头文件，替换宏。经过此种替代，生成一个没有宏定义、没有条件编译指令、没有特殊符号的预编译文件。
  - C++：.i文件
- **编译阶段：**将经过预处理后的**预编译文件**转换成**汇编程序**，生成汇编文件
  - .s文件
- **汇编阶段：**将汇编程序转换成可链接的二进制程序
  - .o文件
- **链接阶段：**将可链接的二进制程序和其它别的库链接在一起，形成可执行的程序文件。



### 4 - 静态链接和动态链接有什么区别？

- 静态链接是在编译链接时直接将需要的执行代码拷贝到调用的地方；
  - 优点在于程序发布时不需要依赖库，可以独立执行
  - 缺点在于程序的体积会相对较大，如果静态库更新，所有可执行文件需要重新链接
- 动态链接是在编译时不直接拷贝执行代码，而是通过记录一系列符号和参数，



### 5 - 隐式类型转换，如何消除隐式类型转换？

- **所谓隐式类型转换，是指不需要用户干预，编译器私下进行的类型转换行为。**很多时候用户可能都不知道进行了哪些转换
- C++面向对象的多态特性，就是通过父类的类型实现对子类的封装。通过隐式转换，你可以直接将一个子类的对象使用父类的类型进行返回。在比如，数值类型和布尔类型的转换，整数和浮点数的转换等。
- 基本数据类型的转换以取值的范围作为转换基础（保证精度不丢失）。**隐式类型转换发生在从小->大的转换中**，低精度的变量给高精度变量赋值会发生隐式类型转换。比如从`char`转换为`int`。从`int`转换为`long`。**自定义对象子类对象可以隐式的转换为父类对象。**
- **C++中提供了`explicit关键字`，在构造函数声明的时候加上`explicit关键字`，能够禁止隐式转换。**
- **如果构造函数只接受一个参数，则它实际上也定义了转换为此类类型的隐式转换机制。可以通过将构造函数声明为`explicit`加以制止隐式类型转换，关键字explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换**，所以无需将这些构造函数指定为`explicit`。



### 6 - 写出 float、指针变量 与 “零值” 比较 的 if 语句

```cpp
// float 与 0 比较 epsilon
const float EPSILON = 0.00001;
if ((x>=-EPSILON) && (x <= EPSILON)) 

// 指针变量 与 0 比较
if (p == nullptr)
if (p != nullptr)

```



### 7 - sizeof 和 strlen 有什么区别？

- sizeof 是一个操作符，strlen是库函数
- sizeof计算的是数据类型占内存的大小，strlen计算的是字符串实际的长度
- sizeof 的参数可以是数据的类型，也可以是变量，但strlen的参数只能是以 `\0` 为结尾的字符串
- 编译器在编译时就计算出了 sizeof 的结果，而 strlen 函数必须在运行时才能计算出来。



### 8 - strcpy、sprintf、memcpy的区别

- 操作对象不同：

  - strcpy操作的两个对象是字符串
  - sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串
  - memcpy操作的两个对象就是两个任意可操作的内存地址

- 执行效率不同，memcpy最高，strcpy次之，sprintf效率最低

- 实现功能不同：

  - strcpy主要实现字符串变量的拷贝
  - sprintf主要实现其他数据类型格式化到字符里
  - memcpy主要是内存块间的拷贝

  

### 9 - strcpy strncpy 

- strcpy 是字符串拷贝函数，返回dest的字符串起始地址。函数原型是：

```cpp
char *strcpy(char* dest, const char *src)
```

从src逐字节拷贝到dest，直到遇到`\0`结束，因为**没有指定长度，可能会导致拷贝越界**，造成缓冲区溢出漏洞，安全的版本是**strncpy函数**

- strncpy 是用来复制源字符串的前n个字符，返回dest的字符串起始地址。函数原型是：

```cpp
char *strncpy(char* dest, const char* src, const size_t n)
```

src 和 dest 所指的内存区域不能重叠，且 dest 必须有足够的空间放置n个字符。**如果src字符串长度小于n，则拷贝完字符串后，在dest后追加0，直到n个。如果src的长度大于等于n，就截取src的前n个字符，不会在dest后追加0。**dest必须有足够的空间放置n个字符，否则可能会造成缓冲溢出的错误情况。



### 10 - 结构体可以直接赋值吗？

声明时可以直接初始化赋值；

同一结构体的不同对象之间也可以直接赋值

但是当结构体中含有”指针成员“时一定要小心，当有多个指针指向同一段内存时，某个指针释放这段内存可能会导致其他指针的非法操作。因此在释放前一定要确保其他指针不再使用这段内存空间



### 11 - 全局变量和局部变量有什么区别？操作系统和编译器是怎么知道的？

- 全局变量是整个程序都能访问的变量，谁都可以访问，生命周期从整个程序的运行到结束，程序结束后所占内存得到释放。
- 局部变量存在于模块中，比如子程序，函数，只有在模块范围内才可以访问，其他模块不可直接访问，模块结束（比如函数调用完毕），局部变量就会消失，所占内存得到释放。
- 操作系统和编译器，是通过内存分配的位置来知道的，全局变量分配在全局区并且在程序开始运行的时候被加载，局部变量则分配在堆栈里。

### 12 - ++i 与 i++ 有什么区别？

- ++i是先自增1再返回，i++是先返回i再自增1

```cpp
// 前缀形式：
int& int::operator++() //这里返回的是一个引用形式，就是说函数返回值也可以作为一个左值使用
{
  //函数本身无参，意味着是在自身空间内增加1的
  *this += 1;  // 增加
  return *this;  // 取回值
}

// 后缀形式:函数返回值是一个非左值型的，与前缀形式的差别所在。

const int int::operator++(int)  //函数带参，说明有另外的空间开辟
{
  int oldValue = *this;  // 取回值
  ++ (*this);  // 增加
  return oldValue;  // 返回被取回的值
}
```



### 13 - C++怎么实现一个函数先于main函数运行

#### 方法一：main函数之前声明一个类的全局的对象，其构造函数先于main执行

 如果在main函数之前声明一个类的全局的对象。那么其执行顺序，根据全局对象的生存期和作用域，肯定先于main函数。

```cpp
class simpleClass
{
public:
    simpleClass()
    {
        cout << "simpleClass constructor" << endl;
	}
};

simpleClass g_simple;
int main()
{
    cout << "main" <<endl;
    return 0;
}

// output:
// simpleClass constructor
// main
```

定义在main( )函数之前的全局对象、静态对象的构造函数在main( )函数之前执行

- Main函数执行之前，主要就是初始化系统相关资源；
  - 设置栈指针
  - 初始化static静态和global全局变量，即data段的内容
  - 将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL，等等，即.bss段的内容
  - 全局对象初始化，在main之前调用构造函数
  - 将main函数的参数，argc，argv等传递给main函数，然后才真正运行main函数

- Main函数执行之后
  - 全局对象的析构函数会在main函数之后执行；
  - 可以用_onexit 注册一个函数，它会在main 之后执行;

#### 方法二：__attribute((constructor)) 

```cpp
__attribute((constructor)) void before()
{
    printf("before main\n");
}
```

#### 总结：如果将方法一和方法二写在一起，输出为：

![image-20210817105440097](https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210817105440097.png)

### 14 - 以下四行代码的区别是什么？

```cpp
const char *a = "hello";
char *b = "hello";
const char c[] = "hello";
char d[] = "hello";
```

**const char *a = "hello";**

**char *b = "hello";**

- 字符串`hello`保存在常量区，const本来是修饰a指向的值不能通过a去修改，但是字符串`hello`就在常量区，本就不能改变，所以加不加const没有影响。

**const char c[] = "hello";**

- 这里字符串`hello`本来是保存在栈上的，但是编译器可能会做某些优化，将其放置到常量区。

**char d[] = "hello";**

- 字符串`hello`保存在栈区，可以通过d去修改。



### 15 - 什么是RTTI

- **RTTI(Run Time Type Identification)**即运行时类型检查，程序能够使用基类的指针或引用来检查着这些指针或引用所指的对象的实际派生类型。
- RTTI提供了两个非常有用的操作符：`typeid`和`dynamic_cast`。
  - `typeid操作符`，返回指针和引用所指的实际类型；
  - `dynamic_cast操作符`，将基类类型的指针或引用安全地转换为其派生类类型的指针或引用。



### 16 - C语言是如何进行函数调用的？

每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把函数返回值地址压入栈内，然后把当前函数的esp指针压入栈内。

- ESP（Extended Stack Pointer）为**扩展栈指针**寄存器，是指针寄存器的一种，用于存放函数栈顶指针

### 17 - C语言参数压栈顺序？

从右到左



### 18 - C++函数栈空间和堆空间的最大值？

- 栈空间默认为1M，不过可以调整
- 堆空间默认4GB