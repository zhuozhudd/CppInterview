## 五、内存管理：

### 0 - 内存是如何分区的？

<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210911085352681.png" alt="image-20210911085352681" style="zoom:67%;" />

地址从下向上增长，分别标示了 .text、.data(gvar)、.bss、stack和heap的内存分部情况。 

C++将内存分为：**代码区、常量区、全局区（静态区）、堆区、栈区**  五个部分，

如果分成四个部分，是将 **全局区（静态区）、常量区  归为  数据区**，即 **代码区、数据区、堆区、栈区**

全局区有很多叫法：全局区、静态区、数据区、全局静态区、静态全局区

<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210911091155799.png" alt="image-20210911091155799" style="zoom: 67%;" />

- 代码区：存放二进制代码，属性是只读
- 数据区：
  - 全局区（静态区）：
    - DATA段：存储初始化的全局变量、初始化的静态变量
    - BSS段：存储未初始化的全局变量、未初始化的静态变量，BSS段会在程序执行前**，将内容全部置为0，**所以未初始化的全局变量和未初始化的静态变量的值都为0
  - 常量区：常量区是数据区中划分的一个小区域，里面存放的是常量，如const修饰的全局变量、字符串常量等
- 栈区：由编译器自动分配释放 ，存放函数的参数值、返回值，局部变量的值等。**内存地址由高向低方向生长**，其最大大小由编译时确定，速度快，但自由性差，最大空间不大。
- 堆区：自由申请的空间，用于动态内存分配。**按内存地址由低到高方向生长，**其大小由系统内存/虚拟内存上限决定，速度较慢，但自由性大，可用空间大。 

#### tips：

- **每个线程都会有自己的栈，但是堆空间是共用的。**
- 堆：
  - 使用malloc() / new()申请的内容存储在堆区，堆区由程序员手动分配，因此也需要自己释放，如果不释放会导致内存泄露
  - 内存空间大，但内存空间不连续，因此会产生内存碎片。操作系统中有一个记录空间内存的链表，当收到内存申请时遍历链表，找到第一个空间大于申请空间的堆节点，将该节点分配给程序，并将该节点从链表中删除。一般系统会在该内存空间的首地址处记录本次分配的内存大小，用于delete释放该空间



### 1 - new/delete 和 malloc/free之间有什么关系？

```cpp
int *p = new int[2];
int *q = (int *)malloc(2 * sizeof(int));
```

- `new/delete`是C++关键字，需要编译器支持。`malloc/free`是C语言库函数，需要头文件`stdlib.h`支持；
- 使用`new操作符`申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而`malloc`则需要显式地指出所需内存的尺寸，**对于类类型的对象，new调用构造函数，delete调用析构函数，malloc、free不能**
- `new操作符`内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故**`new`是符合类型安全性的操作符**。而`malloc`内存分配成功则是返回`void * `，需要通过强制类型转换将`void*指针`转换成需要的类型。
- `new内`存分配失败时，会抛出`bad_alloc异常`。`malloc`分配内存失败时返回`NULL`。

以下两点是次要：

- new一般分为两步：new操作 和 构造。new操作对应 malloc，但new操作 可以重载，可以自定义内存分配策略，不做内存分配，甚至分配到非内存设备上，malloc不行。

- `new`会先调用`operator new`函数，申请足够的内存（通常底层使用`malloc`实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。`delete`先调用析构函数，然后调用`operator delete`函数释放内存（通常底层使用free实现）。`malloc/free`是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。



### 2 - delete arr 与 delete[]  arr 有什么区别？

- 对于简单类型来说，使用new分配后，不管是数组形式还是非数组形式，两种方式都可以释放内存

- 对于自定义类型来说，就需要对单个对象使用delete，对于对象数组使用delete[]，逐个调用数组中对象的析构函数，从而释放所有内存；如果反过来使用，对于单个对象用delete[] ，对于对象数组使用 delete，其行为是未定义的
- 最佳的使用方式是：如果用了new，就用delete，如果用了 new[]，就用 delete[]



### 3 - malloc  brk mmap 是什么？

`malloc` 函数用于动态分配内存。为了减少内存碎片和系统调用的开销，`malloc` 采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。

- `malloc `采用**隐式链表**结构将堆区分成连续的、大小不一的块，包含**已分配块和未分配块；**
- `malloc` 采用**显示链表**结构来管理**所有的空闲块**，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。

当进行内存分配时，`malloc` 会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行内存合并时，malloc 采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。

`malloc` 在申请内存时，一般会通过`brk` 或者`mmap `系统调用进行申请。

- 申请内存**小于128K**时，会使用系统函数**`brk `**在**堆区**中分配；
- 当申请内存**大于128K**时，会使用系统函数**`mmap`**在**映射区**分配。



### 4 - 内存块太小导致malloc和new 返回空指针，该怎么处理？

- 对于malloc来说，需要判断是否其返回空指针，如果是则马上用return语句终止该函数或者用exit终止该程序。
- 对于new来说，默认抛出异常，所以可以使用 try catch

```cpp
try
{
    int *ptr = new int [100000000];
}catch(bad_alloc &memExp)
{
    cerr << memExp.what() << endl;
}
```

还可以使用 set_new_handler 函数的方式

```cpp
void no_more_memory()
{
    cerr << "Unable to satisfy request for memory" << endl;
    abort();
}
int main()
{
    set_new_handler(no_more_memory);
    int *ptr = new int[10000000];
}
```



### 5 - 内存泄露的场景有哪些？如何判断内存泄露？如何定位内存泄露？

#### 内存泄露 memory leak：

是指程序申请的内存，用完后没有释放已申请的内存空间，占用有用内存。

- 一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。

#### 内存泄露的场景：

- malloc 和 free 没有成对出现；new / new []  和 delete / delete [] 没有成对出现；

  - 在堆中创建对象分配内存，但没有显示释放内存；比如，通过局部分配的内存，未在调用者函数体内释放：

  ```cpp
  char* getMemory()
  {
      char *p = (char *)malloc(30);
      return p;
  }
  int main()
  {
      char *p = getMemory();
      return 0;
  }
  ```

  - 在构造函数中动态分配内存，但未在析构函数中正确释放内存；

- 未定义拷贝构造函数或未重载赋值运算符，从而造成两次释放相同内存的做法：

  - 比如，类中包含指针成员变量，在未定义拷贝构造函数或未重载赋值运算符的情况下，编译器会调用默认的拷贝构造函数或复制运算符，以逐个成员拷贝的方式来复制指针成员变量，使得两个对象包含指向同一内存空间的指针，那么在释放第一个对象时，析构函数释放该指针指向的内存空间，在释放第二个对象的时候，析构函数就会释放同一内存空间，这是非法的。

- 没有将基类的析构函数定义为虚函数。

#### 判断和定位内存泄露的方法：

使用各种已有的内存泄露检测工具：

- Linux系统中，用 valgrind、matrace 等内存泄露检测工具。



使用静态代码检测工具，但是准确性不一定高，比如：

- Clang-Tidy
- cppcheck



### 6 - 内存溢出是什么？产生的原因？

#### 内存溢出 Out Of Memory：

系统中存在无法回收的内存或使用的内存过多，最终使得程序运行要用到的内存大于能提供的最大内存。此时程序就无法运行，系统会提示内存溢出错误。

- 比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。

##### 内存溢出产生的原因？

- 第一种是指程序中已动态分配的堆内存由于某些原因程序未能释放或无法释放，造成系统内存的浪费，也就是内存泄露；内存泄漏的堆积最终会导致内存溢出

- 另外一种是当需要保存多个耗用内存过大或当加载单个超大对象时，该对象的大小超过了当前剩余的可用内存空间。



### 7 - 内存的分配方式有几种？

- 在栈上分配：执行函数时，局部变量的内存都可以在栈上分配，函数结束时自动释放；栈内存的分配运算内置于处理器的指令集中，效率很高，但分配的内存容量有限。
- 从堆上分配：由new分配、delete释放的内存块，也称动态内存分配，程序员自行申请和释放内存，使用灵活。
- 从自由存储区分配：由malloc分配、free释放的内存块，与堆类似
- 从常量存储区分配：特殊的存储区，存放的是常量，不可修改。
- 从全局/静态存储区分配：编译期间分配内存，整个程序运行期间都存在，如全局变量，静态变量等。



### 8 - 堆和栈有什么区别？

分配和管理方式不同：

- 堆是动态分配的，其空间分配和释放都是由程序员控制
- 栈是由编译器自动管理，其分配方式有两种：
  - 静态分配由编译器完成，比如局部变量的分配；
  - 动态分配由 `alloca()`函数进行分配，但是会由编译器释放

产生碎片不同：

- 对于堆来说，频繁使用 new delete 或 malloc free会造成内存空间的不连续，产生大量碎片，使程序效率降低
- 对于栈来说，不存在碎片问题，因为栈具有先进后出的特性

生长方向不同：

- 堆是向着内存地址增加的方向增长的，从内存的低地址向高地址方向增长；
- 栈是向着内存地址减小的方向增长的，从内存的高地址向低地址方向增长；

申请大小限制不同：

- 堆是不连续的内存区域，其大小可以灵活调整

- 栈顶和栈顶是预设好的，大小固定



### 9 - 静态内存分配和动态内存分配有什么区别？

- 静态内存分配是在编译时期完成的，不占用CPU资源；动态内存分配是在运行时完成的，分配和释放需要占用CPU资源。
- 静态内存分配是在栈上分配的；动态内存分配是在堆上分配的
- 静态内存分配的运行效率比动态内存分配高，动态内存分配不当可能造成内存泄露
- 静态内存分配不需要指针或引用类型的支持；动态内存分配需要
- 静态内存分配是按计划分配的，在编译前确定了内存块的大小；动态内存分配是按需要分配的
- 静态内存分配是把内存的控制权交给了编译器；动态内存分配是把内存的控制权交给了程序员



### 10 - 如何构造一个类，使得只能在堆上或只能在栈上分配内存？

- 只能在堆上：将析构函数声明为 `private`
- 只能在栈上：将 new  和 delete 重载为 private



### 11 - 浅拷贝和深拷贝有什么区别？

浅拷贝只复制指向某个对象的指针，而不复制对象本身。新旧对象还是共享一块内存；

深拷贝会创造一个相同的对象，新对象和原对象不共享能存，修改新对象不会影响原对象



### 12 - 字节对齐的原则是什么？

- 从偏移为0的位置开始存储

- 如果没有定义 #pragma pack(n)

  - sizeof 的最终结果必然是结构内部最大成员的整数倍，不够补全
  - 结构内部各个成员的首地址必然是自身大小的整数倍

- 如果定义了 #pragma pack(n)

  - sizeof 的最终结果必然是 min[n,结构内部最大成员] 的 整数倍，不够补全
  - 结构内部各个成员的首地址必然是 min[n,自身大小] 的整数倍

  

### 13 - 结构体内存对齐问题

常用数据类型所占字节数

```cpp
char: 1
short: 2
int: 4
long: 4
float: 4
double: 8
```

在没有 #pragma pack 宏的情况下，遵循三个原则：

原则1：数据成员对齐规则：结构（struct或联合union）的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小的整数倍开始（比如int在32位机为４字节，则要从4的整数倍地址开始存储）。

原则2： 结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。（struct a里存有struct b，b里有char，int，double等元素，那b应该从8的整数倍开始存储。）

原则3：收尾工作:，结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的整数倍，不足的要补齐。

```cpp
struct A
{
    short a1;
    short a2;
    short a3;
};

struct B
{
    long a1;
    short a2;
};
```

 sizeof(A) = 6; 这个很好理解，三个short都为2。

 sizeof(B) = 8; 这个比是不是比预想的大2个字节？long为4，short为2，整个为8，因为原则3。

```cpp
struct A
{
    int a;
    char b;
    short c;
};

struct B
{
    char b;
    int a;
    short c;
};
```

sizeof(A) = 8; int为4，char为1，short为2，这里用到了原则1和原则3。

sizeof(B) = 12; 是否超出预想范围？char为1，int为4，short为2，怎么会是12？还是原则1和原则3。

 ```
A的内存分布，*代表补齐
a    b  c
1111,1*,11

B的内存分布，*代表补齐
b    a    c
1***,1111,11**
 ```

A中，因为c为short，其起始位置要为2的倍数，就是原则1。c的后面没有补充，因为b和c正好占用4个字节，整个A占用空间为4的倍数，也就是最大成员int类型的倍数，所以不用补充。

B中，b是char为1，b后面补充了3个字节，因为a是int为4，根据原则1，起始位置要为4的倍数，所以b后面要补充3个字节。c后面补充两个字节，根据原则3，整个B占用空间要为4的倍数，c后面不补充，整个B的空间为10，不符，所以要补充2个字节

```cpp
struct A
{
    int a;
    double b;
    float c;
};

struct B
{
    char e[2];
    int f;
    double g;
    short h;
    struct A i;
};
```

sizeof(A) = 24; int为4，double为8，float为4，总长为8的倍数，补齐，所以整个A为24。

sizeof(B) = 48; B的内存布局:

```
 e       f         g              h                                    i 
11**,   1111,   11111111, 11 * * * * * *,   1111* * * *, 11111111, 1111 * * * *
```

如果有#pragma pack宏，对齐方式按照宏的定义来。比如上面的结构体前加#pragma pack(1)，内存的布局就会完全改变。sizeof(A) = 16; sizeof(B) = 32;有了#pragma pack(1)，内存不会再遵循原则1和原则3了，按1字节对齐，没有补全