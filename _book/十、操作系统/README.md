## 十、操作系统

### 1 - 操作系统的特点

- 并发性
- 共享性
- 虚拟性
- 异步性

### 2 - 并发和并行

- **并发（concurrency）：**指**宏观上看起来两个程序在同时运行**，比如说在**单核cpu 上的多任务**。但是从**微观上看两个程序的指令是交织着运行的**，你的指令之间穿插着我的指令，我的指令之间穿插着你的，在单个周期内只运行了一个指令。**这种并发并不能提高计算机的性能，只能提高效率。**
- **并行（parallelism）：**指**严格物理意义上的同时运行**，比如**多核cpu**，**两个程序分别运行在两个核上，两者之间互不影响**，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu 都是往多核方面发展。

### 3 - 同步、异步、阻塞、非阻塞的概念

- **阻塞和非阻塞：**
  - 阻塞：调用者在事件没有发生的时候，一直在等待事件发生，不能去处理别的任务这是阻塞。
  - 非阻塞：调用者在事件没有发生的时候，可以去处理别的任务这是非阻塞。
- **同步和异步：**
  - 同步：调用者要一直等待返回结果，得到通知后才能进行后续的执行，这种情况是同步。
  - 异步：调用者不用自己去查看事件有没有发生，而是等待着注册在事件上的回调函数通知自己，这种情况是异步。

### 4 - 进程与线程的概念

- 进程：是系统进行资源调度和分配的基本单位，且每个进程拥有独立的地址空间，进程实现了操作系统的并发，是系统中并发执行的单位。
- 线程：是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；



### 5 - 进程与线程的区别

答案一：

- **单位：进程是资源分配的最小单位，线程是CPU调度的最小单位。**两者均可并发执行。
- **从属：一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。**线程依赖于进程而存在。
- **资源：进程之间的资源是独立的，进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。**
  - 资源分配给进程，同一进程的所有线程共享该进程的所有资源。
  - 同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。
- **系统开销：在创建或撤销进程时，系统都要为之分配或回收资源，系统开销显著大于创建或撤销线程的开销。**
  - 在进行进程切换时，设计到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。
  - 而线程切换只需要保存和设置少量寄存器的内容，并不涉及存储管理方面的操作。
  - 切换进程的开销也远大于切换线程的开销。
  - 进程编程调试简单可靠性高，但是创建、销毁、切换开销大；线程正相反，但是编程调试相对复杂
- **进程之间不会相互影响，一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃会导致整个进程崩溃。**所以多进程比多线程健壮。

答案二：根本区别就是多进程每个进程有自己的地址空间，线程则是共享地址空间。

- 速度：线程创建速度快，线程间通信快、切换快，因为它们在同一地址空间内
- 资源利用率：线程的资源利用率比较好也是因为它们在同一地址空间
- 同步问题：线程使用公共变量/内存时需要使用同步机制，也是因为它们在同一地址空间内。



### 6 - 多线程与多进程的不同？

- 进程是资源分配的最小单位，而线程时CPU 调度的最小单位。
- **多线程之间共享同一个进程的地址空间**，线程间通信简单，同步复杂，线程创建、销毁和切换简单，速度快，占用内存少，**适用于多核分布式系统**，但是线程间会相互影响，一个线程意外终止会导致同一个进程的其他线程也终止，程序可靠性弱。
- **多进程间拥有各自独立的运行地址空间**，进程间不会相互影响，程序可靠性强，但是进程创建、销毁和切换复杂，速度慢，占用内存多，进程间通信复杂，但是同步简单，**适用于多核、多机分布。**



### 7 - 多线程与多进程的应用场景

- 需要频繁创建销毁的优先用线程；
- 需要进行大量计算的优先使用线程；
- 强相关的处理用线程，弱相关的处理用进程；
- 多线程模型主要优势为线程间切换代价较小，因此适用于I/O 密集型的工作场景，因此I/O密集型的工作场景经常会由于I/O 阻塞导致频繁的切换线程。同时，**多线程模型也适用于单机多核分布式场景。**
- 多进程模型，适用于CPU 密集型。同时，多进程模型也适用于多机分布式场景中，易于多机扩展。



### 8 - 进程的状态转换

进程包括三种状态：就绪、运行、阻塞

<img src="https://gitee.com/song-zhuozhu/my_image/raw/master/img/image-20210912191907237.png" alt="image-20210912191907237" style="zoom:67%;" />

**就绪 -->  运行：对就绪状态的进程，当进程调度程序按一种选定的策略从中选中一个就绪进程，为之分配处理机后，该进程便由就绪状态变为执行状态**

**运行 -->  阻塞：正在执行的进程因发生某等待事件而无法运行，则进程由执行状态变为阻塞状态，**如进程提出输入/输出请求而变成带带外部设备传入信息的状态；进程申请资源（主存空间或外部设备）得不到满足时编程等待资源状态，进程运行中出现了故障（程序出错或主存储器读写错误等）编程等待干预状态等；

**阻塞 -->  就绪：**处于阻塞状态的进程，其等待的事件已经发生，如输入/输出完成；资源得到满足；或错误处理完毕时，处于等待状态的进程并不马上转入运行状态，而是先转入就绪状态，再由系统进程调度程序在适当的时候将改进成转为执行状态。

**运行 -->  就绪 ：**正在执行的进程，因时间片用完而被暂停运行；或在采用抢占式优先级调度算法的系统中，当有更高优先级的进程要运行而被迫让出处理机时，该进程便从运行状态转变为就绪状态



### 9 - 进程的调度算法有哪些？

- 先来先服务调度算法
- 时间片轮转调度算法
- 短作业优先调度算法
- 最短剩余时间优先调度算法：
  - 是针对最短进程优先增加了抢占机制的版本
- 高响应比优先调度算法：
  - 主要用于作业调度，该算法是对 先来先服务调度算法 和 短作业优先调度算法 的一种综合平衡，同时考虑每个作业的等待时间和估计的运行时间
- 优先级调度算法



### 10 - 进程间的通信方式有哪些？

- 管道
- 系统IPC （消息队列、信号量、共享内存）
- 套接字socket

#### 10.1 - 管道

管道主要包括普通管道和命名管道：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程的通信。

**普通管道PIPE：**

- 半双工（数据只能在一个方向上流动），具有固定的读端和写端
- 只能用于具有亲缘关系的进程间通信（也就是父子进程或兄弟进程之间）
- 它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，不属于其他任何文件系统，并且只存在于内存中。
- `int pipe(int fd[2]);`  当一个管道建立时，会创建两个文件文件描述符，要关闭管道只需将这两个文件描述符关闭即可。

**命名管道FIFO：**

- 可以在无关的进程之间交换数据
- 有路径名与之相关联，以一种特殊设备文件形式存在于文件系统中
- `int mkfifo(const char* pathname,mode_t mode);`

#### 10.2 - 系统IPC（Inter-Process Communication）

**消息队列：**

- 消息队列是消息的链表，存放在内核中。一个消息队列由一个标识符来标识（即队列ID）。
- 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级；
- 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除；
- 消息队列可以实现消息的随机查询。

**信号量 semaphore：**

- 信号量是一个计数器，信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据；
- 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存；
- 信号量基于操作系统的PV操作，程序对信号量的操作都是原子操作；
- 每次对信号量的PV操作不仅限于对信号量值+1或-1而是可以加减任意正整数；
- 支持信号量组。

**共享内存 Shared Memory：**

- 共享内存指两个或多个进程共享一块指定的存储区，不同进程可以即时看到对方进程中对共享内存中数据的更新；
- 因为多个进程可以同时操作，所以需要进行同步；
- **信号量和共享内存通常结合在一起使用，信号量用来同步对共享内存的访问；**
- **共享内存是最快的一种进程通信方式，因为进程是直接对内存进行存取。**

#### 10.3 - 套接字 SOCKET

socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。



### 11 - 线程通信方式

#### Linux

- 信号：类似进程间的信号处理
- 锁机制：互斥锁、读写锁、自旋锁
- 条件变量：使用通知的方式解锁，与互斥锁配合使用
- 信号量：包括无名线程信号量和命名线程信号量

#### Windows：

- 全局变量：需要有多个线程来访问一个全局变量时，通常会在这个全局变量上加volatile声明，防止编译器对此变量进行优化
- Message消息机制：常用的Message通信的接口主要有两个：
  - PostMessage 为线程向主窗口发消息
  - PostThreadMessage 是任意两个线程之间的通信接口
- CEvent：CEvent为MFC中的一个对象，可以通过对CEvent的触发状态进行改变，从而实现线程间的通信和同步，是实现线程直接同步的一种方法



### 12 - 线程同步的方式有哪些？

**（1）临界区：**

通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；

**（2）信号量：**

信号量是一种特殊的变量，可用于线程同步。它只取自然数值，并且只支持两种操作：

- P(V)：如果信号量大于 0 ，执行 -1 操作；若S减1后仍大于或等于0，则进程继续执行；若S减1后小于0，则该进程被阻塞后放入等待该信号量的等待队列中，然后转进程调度。
- V(V)：V+1；若结果大于0，则进程继续执行；若相加后结果仍小于或等于0，则从该信号的等待队列中释放一个等待进程，然后再返回原进程继续执行或转进程调度。

其系统调用为：

- `sem_wait（sem_t *sem）：`以原子操作的方式将信号量`-1`，如果信号量值小于`0`，则`sem_wait`将被阻塞，直到这个信号量具有`非0 值`。
- `sem_post（sem_t *sem)：`以原子操作将信号量值`+1`。当信号量`大于0 `时，其他正在调用`sem_wait `等待信号量的线程将被唤醒。

**（3）互斥量：**

互斥量又称互斥锁，主要用于线程互斥，不能保证按序访问，可以和条件锁一起实现同步。当进入临界区时，需要获得互斥锁并且加锁；当离开临界区时，需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程。其主要的系统调用如下：

- **pthread_mutex_init: **初始化互斥锁
- **pthread_mutex_destroy：**销毁互斥锁
- **pthread_mutex_lock：**以原子操作的方式给一个互斥锁加锁，如果目标互斥锁已经被上锁，**pthread_mutex_lock **调用将阻塞，直到该互斥锁的占有者将其解锁。
- **pthread_mutex_unlock: **以一个原子操作的方式给一个互斥锁解锁。

**（4）事件(信号)，Wait/Notify：**

通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

**（5）条件变量：**

条件变量，又称条件锁，用于在线程之间同步共享数据的值。条件变量提供一种线程间通信机制：当某个共享数据达到某个值时，唤醒等待这个共享数据的一个/多个线程。即，当某个共享变量等于某个值时，调用signal/broadcast。此时操作共享变量时需要加锁。其主要的系统调用如下：

- **pthread_cond_init: **初始化条件变量
- **pthread_cond_destroy：**销毁条件变量
- **pthread_cond_signal：**唤醒一个等待目标条件变量的线程。哪个线程被唤醒取决于调度策略和优先级。
- **pthread_cond_wait：**等待目标条件变量。需要一个加锁的互斥锁确保操作的原子性。该函数中在进入`wait `状态前首先进行解锁，然后接收到信号后会再加锁，保证该线程对共享资源正确访问。



### 14 - 线程产生的原因？

进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量；但是**进程具有一些  缺点：**

- 进程在同一时间只能干一件事。
- 进程在执行的过程中如果阻塞，整个进程就会挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行。

因此，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时空开销，提高并发性。

**和进程相比，线程的优势如下：**

- **资源开销小：**在linux 系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种"昂贵"的多任务工作方式。
- 由于多个线程共享同一个进程虚拟空间，线程之间通信更加方便，切换效率更快，比进程更具有更高的性能。

**除以上优点外，多线程程序作为一种多任务、并发的工作方式，还有如下优点：**

- 使多CPU 系统更加有效。操作系统会保证当线程数不大于CPU 数目时，不同的线程运行于不同的CPU 上。
- 改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序才会利于理解和修改



### 15 - 线程切换时需要保存哪些上下文？SP、PC、EAX 这些寄存器的作用？

线程在切换的过程中需要保存：

- 当前线程Id
- 线程状态
- 堆栈
- 寄存器状态

其中**寄存器主要包括SP PC EAX 等寄存器**，其主要功能如下：

- **SP: 堆栈指针**，指向当前栈的栈顶地址
- **PC: 程序计数器**，存储下一条将要执行的指令
- **EAX: 累加寄存器**，用于加法乘法的缺省寄存器



### 16 - 单核机器上写多线程程序，是否需要考虑加锁，为什么？

在单核机器上写多线程程序，仍然**需要线程锁**。因为线程锁通常用来实现线程的同步和通信。在单核机器上的多线程程序，仍然存在线程同步的问题。因为在抢占式操作系统中，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其起，然后运行另一个线程。如果这两个线程共享某些数据，不使用线程锁的前提下，可能会导致共享数据修改引起冲突。



### 17 - 游戏服务器应该为每个用户开辟一个线程还是一个进程？

- 游戏服务器应该为每个用户开辟一个进程。因为同一进程间的线程会相互影响，一个线程死掉会影响其他线程，从而导致进程崩溃。因此为了保证不同用户之间不会相互影响，应该为每个用户开辟一个进程



###  18 - 互斥锁（mutex）机制，互斥锁和读写锁的区别？

- **互斥锁 mutex：**用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。

- **读写锁 rwlock：**分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。**注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者**（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。

**互斥锁和读写锁的区别：**

- 读写锁区分读者和写者，而互斥锁不区分
- 互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。



### 19 - 介绍几种典型的锁？

#### 读写锁

- 多个读者可以同时进行读
- 写者必须互斥（只允许一个写者写，写时不能读，后续读者必须等待，唤醒时优先考虑写者）

#### 互斥锁

**互斥锁用于控制多个线程对他们之间共享资源互斥访问的一个信号量。**也就是说是为了避免多个线程在某一时刻同时操作一个共享资源。

- 一次只能一个线程拥有互斥锁，其他线程只能等待
- 互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时设计上下文的切换。
- 互斥锁的实际效率还是可以接受的，加锁时间大概100ns左右，而实际互斥锁的一种可能的实现锁先自旋一段时间，当自旋的时间超过阈值之后再将线程投入到睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果不亚于使用自旋锁

#### 条件锁

条件锁就是所谓的条件变量，**某一个线程因为某个条件为满足时可以使用条件变量使该程序处于阻塞状态。**一旦条件满足以“信号量”的方式唤醒一个因为该条件而被阻塞的线程。最为常见就是在线程池中，起初没有任务时任务队列为空，此时线程池中的线程因为“任务队列为空”这个条件处于阻塞状态。一旦有任务进来，就会以信号量的方式唤醒一个线程来处理这个任务。

- 互斥锁一个明显的缺点锁它只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现

#### 自旋锁

**如果线程无法取得锁，并不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。**如果别的线程长时间占有锁，那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这时效率锁比较高的。



### 20 - 进程终止的方式 

- 正常退出：自愿
- 错误退出：自愿
- 严重错误：非自愿
- 被其他进程杀死：非自愿 kill



### 21 - 守护进程、僵尸进程、孤儿进程都是什么？

#### 守护进程

指在后台运行的，没有控制终端与之相连的进程。它独立于控制终端，周期性地执行某种任务。Linux的大多数服务器就是用守护进程的方式实现的，如Web服务器进程HTTP等

#### 孤儿进程

如果父进程先退出，子进程还没退出，那么子进程的父进程将变为init进程。（注：任意一个进程都必须有父进程）

一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被init进程（pid = 1）所收养，并由init进程对它们完成状态进行收集工作。

#### 僵尸进程

如果子进程先退出，父进程还没有退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成了僵尸进程。

设置僵尸进程的目的是维护子进程的信息，以便父进程在以后某个时候获取。这些信息至少包括进程ID，进程的终止状态，以及该进程使用CPU的时间，所以当终止子进程的父进程调用wait或waitpid时就可以得到这些信息。

如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程ID将被置为1（init进程）。接管这些子进程的init进程将清理它们（也就是说init进程将wait它们，从而去除它们的僵尸状态）。



### 22 - 如何避免僵尸进程？

- **通过 `signal (SIGCHLD, SIG_IGN )` 通知内核对子进程的结束不关心，由内核回收。如果不想让父进程挂起，可以再父进程中加入一条语句： `signal (SIGCHLD, SIG_IGN )` ;表示父进程忽略 SIGCHLD信号，该信号是子进程退出的时候向父进程发送的。**
- 父进程调用 wait / waitpid 等函数等待子进程结束，如果尚无子进程退出 wait 会导致父进程阻塞。waitpid可以通过传递 WNOHANG使父进程不阻塞立即返回。



---

### 23 - 什么是死锁？

由于系统中存在一些不可剥夺资源，当两个或两个以上进程在执行过程中，因争夺资源而造成的相互等待，使每个进程都无法向前推进的现象，即死锁



### 24 - 产生死锁的原因？

- 竞争资源
  - 例如：系统中只有一台打印机，可供进程A使用，假定A已占用打印机，而B继续要求打印机打印则会被阻塞
  - 系统资源可分两类
    - 可剥夺资源：CPU、主存等
    - 不可剥夺资源：磁带机、打印机等
- 进程推进顺序不当
  - 例如：进程A和进程B相互等待对方的数据



### 25 - 死锁发生的条件有哪些？

死锁发生的四个必要条件如下：

- **互斥条件：**进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源；
- **请求和保持条件：**进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源；
- **不可剥夺条件：**进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放;
- **环路等待条件：**进程发生死锁后，必然存在一个进程-资源之间的环形链。



### 26 - 如何解决死锁？

- 预防死锁：破坏四个必要条件中的一个或多个来预防死锁
- 避免死锁：在资源动态分配的过程中，用某种方式防止系统进入不安全的状态
- 检测死锁：运行时产生死锁，及时发现死锁，将程序解脱出来
- 解除死锁：发生死锁后，撤销进程，回收资源，分配给正在阻塞状态的进程。



### 27 - 如何预防死锁？

- **破坏 请求和保持条件：**
  - 一次性分配所有资源，这样就不会再有请求了
  - 只要有一个资源得不到分配，就不给这个进程分配其他资源
- **破坏 不可剥夺资源：**
  - **当进程新的资源未得到满足时，释放已占有的资源**，从而破坏不可剥夺的条件
- **破坏 环路等待条件：**
  - **资源有序分配法：**系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件



### 28 - 如何避免死锁？

安全状态：如果死锁没有发生，并且及时所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则成该状态是安全的。

使用**银行家算法**检测系统是否处于安全状态，如果每次资源的分配回导致系统进入不安全状态，则不进行分配。



### 29 - 如何解除死锁？

资源剥夺：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他死锁进程

撤销进程：强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源（撤销的原则可以按照进程优先级和撤销进程代价的高低进行）

进程回退：让一个或多个进程回退到足以避免死锁的地步。进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。



### 30 - 物理地址、逻辑地址、虚拟内存的概念？

#### 物理地址：

它是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址从主存中存取，是内存单元的真正地址

#### 逻辑地址：

是指用户看到的地址。逻辑地址并不一定是元素存储的真实地址，即数组元素的物理地址（在内存条中的所处的位置）并非是连续的，只是通过操作系统通过地址映射，将逻辑地址映射成连续的，这样使用更符合人们的直观思维

#### 虚拟内存：

虚拟内存是一种内存管理技术，它会使程序自己认为自己拥有一块很大且连续的内存，然而，这个程序在内存中不是连续的，并且有些还会在磁盘上，在需要时进行数据交换。



### 31 - 分页和分段的区别？

1. 段是信息的逻辑单位，它是根据用户的需要划分的，因此段是对用户可见的；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的；
2. 段的大小不固定，有它所完成的功能决定；页的大小固定，由系统决定
3. 段向用户提供二维地址空间；页向用户提供的是一维地址空间
4. 段是信息的逻辑单位，便于存储保护和信息共享，页的保护和共享收到限制



###  32 - 说一说虚拟地址空间的好处和坏处？

​	  虚拟内存技术使得不同进程在运行过程中，它所看到的是自己独自占有了当前系统的4G 内存。所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data 段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。还有进程运行过程中，要动态分配内存，比如malloc 时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。

#### 虚拟内存的好处

- 扩大地址空间；
- 内存保护：每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改。
- 公平内存分配。采用了虚存之后，每个进程都相当于有同样大小的虚存空间。
- 当进程通信时，可采用虚存共享的方式实现。
- 当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内
- 虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU 交给另一个进程使用。在内存中可以保留多个进程，系统并发度提高
- 在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片

#### 虚拟内存的代价：

- 虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存
- 虚拟地址到物理地址的转换，增加了指令的执行时间。
- 页面的换入换出需要磁盘I/O，这是很耗时的
- 如果一页中只有一部分数据，会浪费内存。



### 33 - 置换算法有哪些？

当访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区，替换一个页，这种现象叫做缺页置换。当前操作系统最常采用的缺页置换算法如下：

- **最佳置换(OPT)算法**：从主存中移出永远不再需要的页面；如无这样的页面存在，则选择最长时间不需要访问的页面。
- **先进先出(FIFO)算法：置换最先调入内存的页面**，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。
- **最近最少使用（LRU）算法: 置换最近一段时间以来最长时间未访问过的页面。**根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。
- **时钟（CLOCK）置换算法**

**当前最常采用的就是LRU 算法。**



### 34 - 缺页中断是什么？

**产生缺页中断的原因是什么？**

`malloc()`和`mmap()`等内存分配函数，在分配时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常。

**缺页中断：**在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存时，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。

**缺页本身是一种中断，与一般的中断一样，需要经过4 个处理步骤：**

- 1、保护CPU 现场
- 2、分析中断原因
- 3、转入缺页中断处理程序进行处理
- 4、恢复CPU 现场，继续执行

**缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：**

- 1、在指令执行期间产生和处理缺页中断信号
- 2、一条指令在执行期间，可能产生多次缺页中断
- 3、缺页中断返回时，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令。



### 35 - 常见的内存分配错误有哪些？

（1）内存分配失败，却使用了它

（2）内存虽然分配成功，但没有初始化就引用它

（3）内存分配成功并且已经初始化，但是操作时越界

（4）忘记释放内存，造成内存泄露

（5）释放了内存后又使用它



### 36 - 内存交换中，被换出的进程保存在哪里？

保存在磁盘里，也就是外存中。

具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。对换区的IO速度比文件区更快

- 文件区主要用于存放文件，追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式；
- 对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。

由于对换区的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出的速度，因此通常对换区采用连续分配方式。



### 37 - 抖动是什么现象？

刚刚换出的页面又要马上换入内存，刚刚换入的页面马上又要换出外存。这种频繁的页面调度行为称之为抖动，或是颠簸现象。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数（分配给进程的物理块不够）

为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率，为了研究应该为每个进程分配多少个物理块，Denning提出了进程**工作集**的概念。



### 38 - 逻辑地址转物理地址

**一句话来说：逻辑地址左移四位加偏移地址就是物理地址**

逻辑地址 = 段地址：偏移地址

具体运算：段地址×16（左移四位，也就是2的四次方，相当于乘16）+偏移地址=物理地址（可以理解为段地址末尾补一个零）

逻辑地址是 1000H：0001H

那么物理地址为1000H×16+0001H=10001H

因为地址本身一般都是十六进制数，所以只需要把段地址左移一位末尾补0再和偏移地址加起来就是物理地址



### 39 - 页表寻址

**页式内存管理**，内存分成固定长度的一个个页片。

操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫页表，页表的内容就是该进程的虚拟地址到物理地址的一个映射。

页表中的每一项都记录了这个页的基地址。通过页表，由逻辑地址的高位部分先找到逻辑地址对应的页基地址，再由页基地址偏移一定长度就得到最后的物理地址，偏移的长度由逻辑地址的低位部分决定。

一般情况下，这个过程都可以由硬件完成，所以效率还是比较高的。页式内存管理的优点就是比较灵活，内存管理以较小的页为单位，方便内存换入换出和扩充地址空间。

**Linux 的四级页表机制：**

64位CPU出现后，硬件可以支持4级页表，即PML4

- **4 级页表分别是：PGD -> PUD -> PMD -> PTE**

| 字段                                           | 描述                       | 位数    |
| ---------------------------------------------- | -------------------------- | ------- |
| PML4 (Page Map Level 4)                        | 指向一个PDPT(页目录指针表) | 位47~39 |
| PGD(Page Global Directory)<br>全局页目录表索引 | 指向PDPT中4个项中的一个    | 位38~30 |
| PMD(Page Middle Directory) <br>页中间目录索引  | 指向页目录中512项中的一个  | 位29~21 |
| PTE(Page Table Entry) <br>页表入口索引         | 指向页表中512项中的一个    | 位20~12 |
| page offset  页内偏移                          | 4KB页中的偏移              | 位11~0  |





### 40 - 外中断和异常有什么区别？

外中断是指CPU执行指令以外的事件引起，如I/O完成中断，表示设备输入/输出处理已经完成，处理机能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等

异常是由CPU执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等



### 41 - 什么是用户态和内核态？为什么要有这两种状态？

用户态和内核态是操作系统的两种运行状态：

- 内核态：处于内核态的CPU可以访问任意的数据，包括外围设备，如网卡、硬盘等，处于内核态的CPU可以从一个程序切换到另一个程序，并且占用CPU不会发生抢占情况，一般处于特权级0的状态称之为内核态。
- 用户态：处于用户态的CPU只能受限的访问内存，并且不允许访问外围设备，用户态下的CPU不允许独占，也就是说CPU能够被其他程序获取。

计算机有一些比较危险的操作，比如设置时钟、内存清理、这些都需要在内核态下完成，如果随意进行操作，系统很容易崩溃



### 42 - 用户态和内核态之间是如何切换的？

所有的用户进程都是运行在用户态的，但是用户进程的访问能力有限，一些必要重要的事件，比如从硬盘读取数据，从键盘获取数据的操作则是只有内核态才能做的事情，而这些数据却又对用户程序非常重要，所以就涉及到两种模式的转换。即：

**用户态 -->  内核态 --> 用户态**

而唯一能够操作这些操作的只有系统调用，而能够执行系统调用的只有操作系统，一般 **用户态 -->  内核态** 的转换 称之为 trap进内核，即**陷阱指令**

执行系统调用完成后，将还原用户模式寄存器，然后再以用户态运行。



### 43 - 什么是缓冲区溢出？有什么危害？

缓冲区是暂时置放输出或输入数据的内存。

**缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法的数据之上。**

造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入是否合理。



计算机中，缓冲区造成的危害主要有以下两点：

- 程序崩溃导致拒绝服务
- 跳转并执行一段恶意代码



### 44 - 原子操作是如何实现的？

处理器使用基于对  **缓存加锁**  或  **总线加锁** 的方式来实现 多处理器之间的原子操作